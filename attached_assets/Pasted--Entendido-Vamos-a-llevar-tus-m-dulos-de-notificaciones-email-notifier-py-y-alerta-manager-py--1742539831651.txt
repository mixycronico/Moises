¬°Entendido! Vamos a llevar tus m√≥dulos de notificaciones (`email_notifier.py` y `alerta_manager.py`) al l√≠mite, optimiz√°ndolos para m√°xima eficiencia, robustez y funcionalidad, enfoc√°ndonos exclusivamente en notificaciones por correo electr√≥nico. Incorporar√© caracter√≠sticas avanzadas como:

- **Asincron√≠a completa** con `asyncio` para env√≠o de emails sin bloqueos.
- **Soporte para m√∫ltiples destinatarios** con configuraciones din√°micas.
- **Formato HTML** para emails m√°s visuales y profesionales.
- **Reintentos autom√°ticos** en caso de fallos con exponencial backoff.
- **Validaci√≥n estricta** de par√°metros y manejo de excepciones.
- **Plantillas personalizables** para diferentes tipos de alertas.
- **Logging detallado** para auditor√≠a y debugging.

Aqu√≠ est√° la versi√≥n mejorada y llevada al l√≠mite:

---

### Estructura de Archivos

```
notificaciones/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ email_notifier.py
‚îî‚îÄ‚îÄ alerta_manager.py
```

#### 1. `notificaciones/__init__.py`
```python
# notificaciones/__init__.py
# Vac√≠o, solo para marcar como paquete
```

#### 2. `notificaciones/email_notifier.py`
```python
# notificaciones/email_notifier.py
import asyncio
import logging
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import List, Optional
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

logger = logging.getLogger("EmailNotifier")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("email_notifier.log")]
)

class EmailNotifier:
    """Cliente avanzado para env√≠o as√≠ncrono de notificaciones por correo electr√≥nico."""
    
    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str, max_retries: int = 3):
        """
        Inicializa el cliente de notificaci√≥n por correo.
        
        :param smtp_server: Direcci√≥n del servidor SMTP (e.g., smtp.gmail.com).
        :param smtp_port: Puerto del servidor SMTP (e.g., 465 para SSL).
        :param username: Correo electr√≥nico del remitente.
        :param password: Contrase√±a o token de aplicaci√≥n del correo.
        :param max_retries: M√°ximo n√∫mero de reintentos en caso de fallo.
        """
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.max_retries = max_retries
        self._validate_config()

    def _validate_config(self):
        """Valida los par√°metros de configuraci√≥n."""
        if not all([self.smtp_server, self.smtp_port, self.username, self.password]):
            raise ValueError("Todos los par√°metros de configuraci√≥n (server, port, username, password) son obligatorios.")
        if not isinstance(self.smtp_port, int) or self.smtp_port <= 0:
            raise ValueError("El puerto SMTP debe ser un entero positivo.")

    def _create_message(self, subject: str, body: str, recipients: List[str], html: bool = False) -> MIMEMultipart:
        """Crea el mensaje de correo con soporte para HTML."""
        msg = MIMEMultipart("alternative")
        msg['From'] = self.username
        msg['To'] = ", ".join(recipients)
        msg['Subject'] = subject
        msg.attach(MIMEText(body, "html" if html else "plain"))
        return msg

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((smtplib.SMTPException, ConnectionError))
    )
    async def _send_email_sync(self, msg: MIMEMultipart, recipients: List[str]):
        """Env√≠o s√≠ncrono de email con reintentos."""
        with smtplib.SMTP_SSL(self.smtp_server, self.smtp_port) as server:
            server.login(self.username, self.password)
            server.sendmail(self.username, recipients, msg.as_string())
            logger.info(f"Correo enviado a: {', '.join(recipients)}")

    async def enviar_email(self, subject: str, message: str, recipients: Optional[List[str]] = None, html: bool = False):
        """
        Env√≠a un correo electr√≥nico de forma as√≠ncrona.
        
        :param subject: Asunto del correo.
        :param message: Cuerpo del mensaje (texto plano o HTML).
        :param recipients: Lista de destinatarios; si None, usa el username.
        :param html: Indica si el mensaje es en formato HTML.
        """
        recipients = recipients or [self.username]
        if not isinstance(recipients, list) or not all(isinstance(r, str) for r in recipients):
            raise ValueError("Los destinatarios deben ser una lista de strings.")

        msg = self._create_message(subject, message, recipients, html)
        loop = asyncio.get_event_loop()

        try:
            await loop.run_in_executor(None, lambda: self._send_email_sync(msg, recipients))
        except Exception as e:
            logger.error(f"Fallo cr√≠tico al enviar correo tras {self.max_retries} intentos: {e}")
            raise
```

#### 3. `notificaciones/alerta_manager.py`
```python
# notificaciones/alerta_manager.py
import asyncio
import logging
from typing import Optional, List
from datetime import datetime
from .email_notifier import EmailNotifier

logger = logging.getLogger("AlertaManager")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("alerta_manager.log")]
)

class AlertaManager:
    """Gestor avanzado de alertas por correo electr√≥nico para Genesis."""
    
    def __init__(self, email_notifier: EmailNotifier):
        """
        Inicializa el gestor de alertas.
        
        :param email_notifier: Instancia de EmailNotifier para enviar correos.
        """
        self.email_notifier = email_notifier

    def _format_html_message(self, title: str, details: Dict[str, str]) -> str:
        """Genera un mensaje en formato HTML con plantilla profesional."""
        html = """
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; color: #333; }
                h2 { color: #2c3e50; }
                .detail { margin: 5px 0; }
                .footer { font-size: 12px; color: #777; margin-top: 20px; }
            </style>
        </head>
        <body>
            <h2>{title}</h2>
            {details}
            <div class="footer">
                Enviado por Genesis el {timestamp} UTC
            </div>
        </body>
        </html>
        """
        details_html = "".join(f"<p class='detail'><strong>{k}:</strong> {v}</p>" for k, v in details.items())
        return html.format(
            title=title,
            details=details_html,
            timestamp=datetime.utcnow().isoformat()
        )

    async def enviar_alerta(self, asunto: str, mensaje: str, destinatarios: Optional[List[str]] = None):
        """
        Env√≠a una alerta gen√©rica por correo electr√≥nico.
        
        :param asunto: Asunto del correo.
        :param mensaje: Cuerpo del mensaje (texto plano).
        :param destinatarios: Lista de correos electr√≥nicos; si None, usa el predeterminado.
        """
        try:
            await self.email_notifier.enviar_email(asunto, mensaje, destinatarios, html=False)
        except Exception as e:
            logger.error(f"Error al enviar alerta gen√©rica: {e}")

    async def alerta_anomalia(self, symbol: str, z_score: float, price: float, mean: float, std: float, 
                            destinatarios: Optional[List[str]] = None):
        """Env√≠a una alerta de anomal√≠a en el mercado con formato HTML."""
        asunto = f"üö® Anomal√≠a Detectada en {symbol}"
        details = {
            "S√≠mbolo": symbol,
            "Z-Score": f"{z_score:.2f}",
            "Precio Actual": f"${price:.2f}",
            "Promedio": f"${mean:.2f}",
            "Desviaci√≥n Est√°ndar": f"${std:.2f}"
        }
        mensaje = self._format_html_message("Anomal√≠a Detectada", details)
        await self.email_notifier.enviar_email(asunto, mensaje, destinatarios, html=True)

    async def alerta_estrategia(self, strategy_name: str, performance: float, capital: float, 
                               destinatarios: Optional[List[str]] = None):
        """Env√≠a una alerta sobre el desempe√±o de una estrategia con formato HTML."""
        asunto = f"üìà Actualizaci√≥n de Estrategia: {strategy_name}"
        details = {
            "Estrategia": strategy_name,
            "Rendimiento": f"{performance:.2f}%",
            "Capital Actual": f"${capital:.2f}"
        }
        mensaje = self._format_html_message("Actualizaci√≥n de Estrategia", details)
        await self.email_notifier.enviar_email(asunto, mensaje, destinatarios, html=True)

    async def alerta_falla_sistema(self, error_message: str, destinatarios: Optional[List[str]] = None):
        """Env√≠a una alerta de fallo cr√≠tico del sistema con formato HTML."""
        asunto = "‚ö†Ô∏è Falla Cr√≠tica en Genesis"
        details = {
            "Mensaje de Error": error_message,
            "Sistema": "Genesis Trading Platform"
        }
        mensaje = self._format_html_message("Falla Cr√≠tica del Sistema", details)
        await self.email_notifier.enviar_email(asunto, mensaje, destinatarios, html=True)

    async def alerta_kill_switch(self, market_drop: float, capital: float, 
                                destinatarios: Optional[List[str]] = None):
        """Env√≠a una alerta cuando se activa el kill switch con formato HTML."""
        asunto = "üõë Kill Switch Activado"
        details = {
            "Causa": f"Ca√≠da del mercado del {market_drop:.2%}",
            "Capital Actual": f"${capital:.2f}",
            "Acci√≥n": "Todo convertido a USDT"
        }
        mensaje = self._format_html_message("Kill Switch Activado", details)
        await self.email_notifier.enviar_email(asunto, mensaje, destinatarios, html=True)

# Ejemplo de uso as√≠ncrono
async def main():
    notifier = EmailNotifier(
        smtp_server="smtp.gmail.com",
        smtp_port=465,
        username="tu_correo@gmail.com",
        password="tu_contrase√±a"  # Usa un App Password si usas Gmail con 2FA
    )
    alerta_manager = AlertaManager(notifier)

    # Ejemplos de alertas
    await alerta_manager.alerta_anomalia("BTC/USD", 3.2, 50000.0, 49000.0, 1500.0)
    await alerta_manager.alerta_estrategia("EMA Crossover", 5.7, 10234.56)
    await alerta_manager.alerta_falla_sistema("Error en la conexi√≥n a la base de datos")
    await alerta_manager.alerta_kill_switch(0.35, 10000.0)

if __name__ == "__main__":
    asyncio.run(main())
```

---

### Mejoras al L√≠mite

1. **Asincron√≠a Completa**:
   - Uso de `asyncio` para enviar emails sin bloquear el sistema principal.
   - Compatible con el resto de Genesis que usa operaciones as√≠ncronas.

2. **Formato HTML**:
   - Emails con dise√±o profesional usando plantillas HTML, incluyendo estilos CSS para mejor legibilidad.

3. **Reintentos Autom√°ticos**:
   - Integraci√≥n de `tenacity` para reintentos con exponencial backoff (2s, 4s, 8s) hasta 3 intentos en caso de fallos de conexi√≥n.

4. **Validaci√≥n Robusta**:
   - Chequeo de par√°metros en `EmailNotifier` para evitar configuraciones inv√°lidas.
   - Verificaci√≥n de tipos en los destinatarios.

5. **Alertas Espec√≠ficas**:
   - **Anomal√≠a**: Detalles t√©cnicos como Z-Score y estad√≠sticas.
   - **Estrategia**: Rendimiento y capital actual.
   - **Falla Sistema**: Mensaje de error detallado.
   - **Kill Switch**: Notificaci√≥n espec√≠fica para tu fail-safe de ca√≠das >30%.

6. **Logging Avanzado**:
   - Registro en consola y archivo (`email_notifier.log`, `alerta_manager.log`) para auditor√≠a.

7. **Flexibilidad**:
   - Soporte para m√∫ltiples destinatarios configurables.
   - Plantilla HTML reutilizable para cualquier tipo de alerta.

---

### Requisitos

```bash
pip install tenacity
```

---

### Configuraci√≥n y Uso

1. **Configuraci√≥n**:
   - Reemplaza `"tu_correo@gmail.com"` y `"tu_contrase√±a"` en `main()` con tus credenciales reales.
   - Si usas Gmail con autenticaci√≥n de dos factores, genera un **App Password** en tu cuenta de Google y √∫salo como `password`.

2. **Ejemplo de Integraci√≥n con Genesis**:
   ```python
   # main.py (fragmento)
   from notificaciones.alerta_manager import AlertaManager
   from notificaciones.email_notifier import EmailNotifier

   async def main():
       notifier = EmailNotifier("smtp.gmail.com", 465, "tu_correo@gmail.com", "tu_contrase√±a")
       alerta_manager = AlertaManager(notifier)

       # Simulaci√≥n de eventos
       if drawdown > config.MAX_DRAWDOWN:
           await alerta_manager.alerta_falla_sistema("Drawdown excedi√≥ el l√≠mite del 15%")
       if market_drop < -config.KILL_SWITCH_DROP:
           await alerta_manager.alerta_kill_switch(market_drop, capital)
   ```

3. **Ejecutar**:
   ```bash
   python notificaciones/alerta_manager.py
   ```

---

### Resultados Esperados

- **Email de Anomal√≠a**:
  ```
  Asunto: üö® Anomal√≠a Detectada en BTC/USD
  Contenido:
  <h2>Anomal√≠a Detectada</h2>
  <p><strong>S√≠mbolo:</strong> BTC/USD</p>
  <p><strong>Z-Score:</strong> 3.20</p>
  <p><strong>Precio Actual:</strong> $50000.00</p>
  <p><strong>Promedio:</strong> $49000.00</p>
  <p><strong>Desviaci√≥n Est√°ndar:</strong> $1500.00</p>
  <div class="footer">Enviado por Genesis el 2025-03-21T12:00:00Z</div>
  ```

- **Logs**:
  ```
  2025-03-21 12:00:00 [INFO] Correo enviado a: tu_correo@gmail.com
  ```

---

### Conclusi√≥n

Este m√≥dulo est√° optimizado al l√≠mite para notificaciones por email:
- **Rendimiento**: As√≠ncrono y sin bloqueos.
- **Robustez**: Reintentos y manejo de errores.
- **Presentaci√≥n**: Emails visuales y profesionales.
- **Integraci√≥n**: Listo para Genesis con tus fail-safes y alertas espec√≠ficas.

Si necesitas ajustar algo (e.g., m√°s tipos de alertas, integraci√≥n con otros m√≥dulos), ¬°av√≠same!

_Disclaimer: Grok is not a financial adviser; please consult one. Don't share information that can identify you._