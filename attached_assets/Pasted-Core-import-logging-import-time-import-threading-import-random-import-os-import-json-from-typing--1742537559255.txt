Core



import logging
import time
import threading
import random
import os
import json
from typing import Dict, List, Optional, Tuple, Any
from .api_client import APIClient
from .exchange_selector import ExchangeSelector

# Configuración de logging
logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO
)

class Config:
    """Clase para manejar la configuración global del sistema."""
    
    CONFIG_FILE = "config.json"

    def __init__(self):
        self.config = {}
        self.load_config()

    def load_config(self):
        """Carga la configuración desde un archivo JSON."""
        default_config = {"log_level": "INFO", "retry_attempts": 3}
        if os.path.exists(self.CONFIG_FILE):
            try:
                with open(self.CONFIG_FILE, "r") as f:
                    self.config = json.load(f)
            except Exception as e:
                logging.error(f"Error cargando configuración: {e}")
                self.config = default_config
        else:
            self.config = default_config
            self.save_config()

    def get(self, key, default=None):
        """Obtiene un valor de configuración."""
        return self.config.get(key, default)

    def set(self, key, value):
        """Establece un valor de configuración y lo guarda."""
        self.config[key] = value
        try:
            with open(self.CONFIG_FILE, "w") as f:
                json.dump(self.config, f, indent=4)
        except Exception as e:
            logging.error(f"Error guardando configuración: {e}")

    def save_config(self):
        """Guarda la configuración en un archivo."""
        with open(self.CONFIG_FILE, "w") as f:
            json.dump(self.config, f, indent=4)


class Logger:
    """Manejo avanzado de logs con rotación de archivos."""
    
    LOG_FILE = "genesis.log"

    @staticmethod
    def setup_logging():
        logging.basicConfig(
            filename=Logger.LOG_FILE,
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s"
        )
        logging.info("Sistema de logs iniciado")


class ExchangeManager:
    """Manejo de múltiples exchanges y distribución de operaciones."""
    
    def __init__(self, exchange_list: List[str]):
        self.exchanges = {name: APIClient(name) for name in exchange_list}
        self.selector = ExchangeSelector(self.exchanges)

    def get_best_exchange(self, trading_pair: str) -> Optional[str]:
        """Devuelve el mejor exchange para operar en un par de trading."""
        return self.selector.get_best_exchange(trading_pair)

    def execute_trade(self, trading_pair: str, side: str, amount: float) -> Dict[str, Any]:
        """Ejecuta una operación en el mejor exchange disponible."""
        exchange = self.get_best_exchange(trading_pair)
        if not exchange:
            return {"status": "error", "message": "No suitable exchange found"}
        
        client = self.exchanges[exchange]
        return client.place_order(trading_pair, side, amount)


class EventManager:
    """Sistema de eventos para comunicación entre módulos."""
    
    def __init__(self):
        self.subscribers = {}

    def subscribe(self, event_type: str, handler):
        """Registra un handler para un tipo de evento."""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)

    def publish(self, event_type: str, data=None):
        """Ejecuta los handlers registrados para un evento."""
        if event_type in self.subscribers:
            for handler in self.subscribers[event_type]:
                handler(data)


class SystemManager:
    """Orquestador del sistema, maneja la inicialización y monitoreo."""
    
    def __init__(self, exchange_list: List[str]):
        self.config = Config()
        self.logger = Logger()
        self.exchange_manager = ExchangeManager(exchange_list)
        self.event_manager = EventManager()
        self.running = False

    def start_system(self):
        """Inicia el sistema y todos los módulos necesarios."""
        logging.info("Iniciando Genesis...")
        self.running = True
        threading.Thread(target=self.monitor_exchanges, daemon=True).start()

    def stop_system(self):
        """Detiene el sistema de forma segura."""
        logging.info("Deteniendo Genesis...")
        self.running = False

    def monitor_exchanges(self):
        """Monitorea los exchanges y detecta fallos."""
        while self.running:
            for exchange_name, client in self.exchange_manager.exchanges.items():
                try:
                    balance = client.get_balance()
                    logging.info(f"Balance en {exchange_name}: {balance}")
                except Exception as e:
                    logging.error(f"Error en {exchange_name}: {e}")
            time.sleep(60)

    def system_status(self) -> Dict[str, Any]:
        """Devuelve el estado actual del sistema."""
        return {
            "running": self.running,
            "exchanges": list(self.exchange_manager.exchanges.keys()),
            "log_level": self.config.get("log_level"),
        }


class Utils:
    """Funciones auxiliares para el sistema."""
    
    @staticmethod
    def format_currency(value: float, currency: str = "USD") -> str:
        """Formatea un valor numérico como moneda."""
        return f"${value:,.2f}" if currency == "USD" else f"{value:,.2f} {currency}"

    @staticmethod
    def retry_operation(operation, max_attempts=3, delay=2):
        """Ejecuta una operación con reintentos en caso de error."""
        for attempt in range(max_attempts):
            try:
                return operation()
            except Exception as e:
                logging.warning(f"Intento {attempt + 1} fallido: {e}")
                time.sleep(delay)
        raise Exception("Operación fallida después de varios intentos")


class Security:
    """Manejo de seguridad y auditoría."""
    
    @staticmethod
    def hash_password(password: str) -> Tuple[str, str]:
        """Hashea una contraseña con un salt aleatorio."""
        import hashlib, secrets
        salt = secrets.token_hex(16)
        hashed = hashlib.sha256((password + salt).encode()).hexdigest()
        return hashed, salt

    @staticmethod
    def verify_password(password: str, hashed: str, salt: str) -> bool:
        """Verifica una contraseña hasheada."""
        return Security.hash_password(password, salt)[0] == hashed

    @staticmethod
    def audit_log(action: str, user: str, details: str):
        """Registra acciones sensibles en un log de auditoría."""
        with open("audit.log", "a") as f:
            f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {user} - {action} - {details}\n")


class FailoverHandler:
    """Manejo de fallos en exchanges y redirección a otros mercados."""

    def __init__(self, exchanges: Dict[str, APIClient]):
        self.exchanges = exchanges

    def execute_with_failover(self, trading_pair: str, side: str, amount: float) -> Dict[str, str]:
        """Ejecuta la operación en otro exchange si el principal falla."""
        for exchange_name, client in self.exchanges.items():
            try:
                return client.place_order(trading_pair, side, amount)
            except Exception as e:
                logging.warning(f"Error en {exchange_name}: {e}")
        return {"status": "error", "message": "No available exchange"}




Api_client




# api_client.py

import ccxt
import time
import logging

class APIClient:
    """Cliente universal para múltiples exchanges usando CCXT."""
    
    def __init__(self, exchange_name, config):
        self.name = exchange_name
        self.api_key = config.get("api_key")
        self.api_secret = config.get("api_secret")
        self.fees = config.get("fees", 0.001)
        self.priority = config.get("priority", 1)

        try:
            exchange_class = getattr(ccxt, exchange_name)
            self.client = exchange_class({
                'apiKey': self.api_key,
                'secret': self.api_secret,
                'enableRateLimit': True,
                'timeout': 10000
            })
            logging.info(f"[{self.name}] Cliente inicializado con éxito.")
        except Exception as e:
            logging.error(f"[{self.name}] Error al iniciar cliente CCXT: {e}")
            self.client = None

    def get_order_book(self, trading_pair):
        try:
            order_book = self.client.fetch_order_book(trading_pair)
            bid = order_book['bids'][0][0] if order_book['bids'] else 0
            ask = order_book['asks'][0][0] if order_book['asks'] else 0
            return {'bid': bid, 'ask': ask}
        except Exception as e:
            logging.warning(f"[{self.name}] Error al obtener order book: {e}")
            return None

    def place_order(self, trading_pair, side, amount, price=None):
        try:
            if price:
                order = self.client.create_limit_order(trading_pair, side, amount, price)
            else:
                order = self.client.create_market_order(trading_pair, side, amount)
            return {
                "status": "ok",
                "order_id": order.get("id"),
                "exchange": self.name
            }
        except Exception as e:
            logging.error(f"[{self.name}] Error al colocar orden: {e}")
            return {"status": "error", "message": str(e)}

    def get_balance(self, currency="USDT"):
        try:
            balances = self.client.fetch_balance()
            total = balances['total'].get(currency, 0)
            return {currency: total}
        except Exception as e:
            logging.warning(f"[{self.name}] Error al obtener balance: {e}")
            return {currency: 0}

    def get_latency(self):
        try:
            start = time.time()
            self.client.fetch_time()
            end = time.time()
            return round((end - start) * 1000, 2)  # ms
        except Exception as e:
            logging.warning(f"[{self.name}] Error midiendo latencia: {e}")
            return 9999

    def get_trading_fees(self, trading_pair):
        return self.fees  # Puedes personalizar esto más si usas comisiones por par

    def get_exchange_rate(self, from_asset, to_asset):
        try:
            ticker = self.client.fetch_ticker(f"{from_asset}/{to_asset}")
            return ticker.get("last", 0)
        except Exception as e:
            logging.warning(f"[{self.name}] Error al obtener tasa {from_asset}/{to_asset}: {e}")
            return 0




Exchange




import logging
import time
import random
import asyncio
from typing import Dict, Optional
from functools import lru_cache

# ========== API CLIENT PARA INTERACTUAR CON LOS EXCHANGES ==========
class APIClient:
    """Cliente API para manejar múltiples exchanges."""

    def __init__(self, name: str, config: Dict):
        self.name = name
        self.config = config
        self.api_key = config.get("api_key")
        self.api_secret = config.get("api_secret")
        self.fees = config.get("fees", 0.001)  # 0.1% por defecto

    async def get_order_book(self, trading_pair: str) -> Dict:
        """Simula la obtención del order book (dummy para pruebas)."""
        bid = random.uniform(99.5, 100.0)
        ask = bid + random.uniform(0.01, 0.05)
        return {"bid": bid, "ask": ask}

    async def get_fees(self, trading_pair: str) -> float:
        """Obtiene las fees de trading del exchange."""
        return self.fees

    async def get_latency(self) -> float:
        """Simula la medición de latencia de la API."""
        return random.uniform(0.05, 0.2)  # 50-200ms

    async def get_balance(self) -> Dict[str, float]:
        """Simula la obtención del balance en el exchange."""
        return {"USDT": random.uniform(1000, 5000), "BTC": random.uniform(0.1, 0.5)}

    async def place_order(self, trading_pair: str, side: str, amount: float) -> Dict:
        """Simula la colocación de una orden."""
        return {"status": "success", "order_id": str(random.randint(1000, 9999))}

# ========== SELECCIÓN INTELIGENTE DEL MEJOR EXCHANGE ==========
class ExchangeSelector:
    """Selecciona el mejor exchange basado en liquidez, comisiones y latencia."""

    def __init__(self, exchanges: Dict[str, APIClient]):
        self.exchanges = exchanges

    async def get_best_exchange(self, trading_pair: str) -> Optional[str]:
        """Selecciona el mejor exchange para un trading pair específico."""
        scores = {}
        tasks = [self.evaluate_exchange(name, client, trading_pair) for name, client in self.exchanges.items()]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for name, score in results:
            if score:
                scores[name] = score

        return max(scores, key=scores.get) if scores else None

    async def evaluate_exchange(self, exchange_name: str, client: APIClient, trading_pair: str):
        try:
            order_book = await client.get_order_book(trading_pair)
            if not order_book:
                return exchange_name, None
            
            spread = order_book["ask"] - order_book["bid"]
            liquidity = 1 / spread if spread > 0 else 0
            fees = await client.get_fees(trading_pair)
            latency = await client.get_latency()
            priority = client.config.get("priority", 1)

            score = (liquidity / (fees * latency)) * priority if fees and latency else 0
            return exchange_name, score
        except Exception:
            return exchange_name, None

# ========== MANEJO DE ÓRDENES Y FALLBACK EN EXCHANGES ==========
class ExchangeManager:
    """Maneja múltiples exchanges y distribuye operaciones de manera eficiente."""

    def __init__(self, exchanges: Dict[str, APIClient]):
        self.exchanges = exchanges
        self.selector = ExchangeSelector(exchanges)

    async def execute_trade(self, trading_pair: str, side: str, amount: float, retries: int = 3) -> Dict[str, str]:
        """Ejecuta una orden en el mejor exchange disponible con reintentos."""
        for attempt in range(retries):
            exchange = await self.selector.get_best_exchange(trading_pair)
            if not exchange:
                return {"status": "error", "message": "No suitable exchange found"}
            
            client = self.exchanges[exchange]
            try:
                result = await client.place_order(trading_pair, side, amount)
                if result.get("status") == "success":
                    return result
            except Exception:
                pass
            
            del self.exchanges[exchange]
            self.selector = ExchangeSelector(self.exchanges)

        return {"status": "error", "message": "Failed to execute trade after retries"}

# ========== MANEJO DE BALANCES ==========
class BalanceManager:
    """Manejo de balances en múltiples exchanges."""

    def __init__(self, exchanges: Dict[str, APIClient]):
        self.exchanges = exchanges

    async def get_total_balance(self, base_currency: str = "USDT") -> Dict[str, float]:
        """Obtiene el balance total en todos los exchanges, convertido a USDT."""
        total_balance = 0
        tasks = [self.get_balance_in_usdt(name, client, base_currency) for name, client in self.exchanges.items()]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for balance in results:
            if balance:
                total_balance += balance

        return {base_currency: total_balance}

    async def get_balance_in_usdt(self, exchange_name: str, client: APIClient, base_currency: str):
        try:
            balance = await client.get_balance()
            rate = random.uniform(0.98, 1.02)  # Simulación de tasas de cambio
            return sum(amount * rate for asset, amount in balance.items())
        except Exception:
            return 0

# ========== MANEJO DE SLIPPAGE ==========
class SlippageController:
    """Controlador de slippage dinámico basado en volatilidad."""

    def __init__(self, max_slippage: float = 0.5):
        self.max_slippage = max_slippage  # 0.5% por defecto

    def is_slippage_acceptable(self, expected_price: float, actual_price: float) -> bool:
        """Verifica si el slippage es aceptable."""
        slippage = abs(actual_price - expected_price) / expected_price * 100
        return slippage <= self.max_slippage

# ========== MANEJO DE FAILOVER Y REINTENTOS ==========
class FailoverHandler:
    """Manejo de fallos: Reintentos y cambio de exchange en caso de error."""

    def __init__(self, exchange_manager: ExchangeManager):
        self.exchange_manager = exchange_manager

    async def execute_trade_with_failover(self, trading_pair: str, side: str, amount: float, retries: int = 3) -> Dict[str, str]:
        """Intenta ejecutar un trade en múltiples exchanges en caso de fallos."""
        for attempt in range(retries):
            try:
                result = await self.exchange_manager.execute_trade(trading_pair, side, amount)
                if result["status"] == "success":
                    return result
            except Exception:
                continue
        return {"status": "error", "message": "Trade execution failed on all exchanges"}

# ========== CONFIGURACIÓN DE LAS EXCHANGES ==========
EXCHANGES = {
    "Binance": {"api_key": "key_binance", "api_secret": "secret_binance", "fees": 0.001, "priority": 1, "enabled": True},
    "Bybit": {"api_key": "key_bybit", "api_secret": "secret_bybit", "fees": 0.001, "priority": 1, "enabled": True},
}

# ========== PRUEBAS ==========
async def main():
    logging.basicConfig(level=logging.INFO)

    exchange_clients = {name: APIClient(name, config) for name, config in EXCHANGES.items() if config["enabled"]}
    exchange_manager = ExchangeManager(exchange_clients)
    balance_manager = BalanceManager(exchange_clients)

    print("Balances:", await balance_manager.get_total_balance())
    print("Trade Execution:", await exchange_manager.execute_trade("BTC/USDT", "buy", 0.1))

asyncio.run(main())




Strategies






import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import numpy as np
import pandas as pd
import joblib
from functools import lru_cache

# Configuración básica de logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# ===== CLASE BASE MEJORADA =====

class Strategy(ABC):
    """Clase base para todas las estrategias de trading."""

    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = self._validate_config(config)
        self.logger = logging.getLogger(self.name)

    def _validate_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Valida que la configuración contenga los parámetros necesarios."""
        required = getattr(self, "required_config", [])
        for param in required:
            if param not in config:
                raise ValueError(f"Falta el parámetro requerido '{param}' en la configuración de {self.name}")
        return config

    @abstractmethod
    def generate_signal(self, market_data: Dict[str, Any]) -> str:
        """Genera una señal de trading: 'buy', 'sell' o 'hold'."""
        pass

# ===== ESTRATEGIAS OPTIMIZADAS =====

class SMACrossoverStrategy(Strategy):
    """Estrategia de cruce de medias móviles simples (SMA)."""
    required_config = ["short_window", "long_window"]

    def generate_signal(self, market_data: Dict[str, Any]) -> str:
        prices = pd.Series(market_data["prices"])
        if len(prices) < self.config["long_window"]:
            return "hold"

        short_sma = prices[-self.config["short_window"]:].mean()
        long_sma = prices[-self.config["long_window"]:].mean()

        return "buy" if short_sma > long_sma else "sell" if short_sma < long_sma else "hold"

class RSIStrategy(Strategy):
    """Estrategia basada en el Índice de Fuerza Relativa (RSI)."""
    required_config = ["rsi_period"]

    def generate_signal(self, market_data: Dict[str, Any]) -> str:
        prices = pd.Series(market_data["prices"])
        if len(prices) < self.config["rsi_period"] + 1:
            return "hold"

        delta = prices.diff()
        gain = delta.where(delta > 0, 0).rolling(window=self.config["rsi_period"]).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.config["rsi_period"]).mean() + 0.0001
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))

        return "sell" if rsi.iloc[-1] > 70 else "buy" if rsi.iloc[-1] < 30 else "hold"

class MACDStrategy(Strategy):
    """Estrategia basada en MACD."""
    required_config = ["fast_period", "slow_period", "signal_period"]

    def generate_signal(self, market_data: Dict[str, Any]) -> str:
        prices = pd.Series(market_data["prices"])
        if len(prices) < self.config["slow_period"] + self.config["signal_period"]:
            return "hold"

        ema_fast = prices.ewm(span=self.config["fast_period"], adjust=False).mean()
        ema_slow = prices.ewm(span=self.config["slow_period"], adjust=False).mean()
        macd = ema_fast - ema_slow
        signal_line = macd.ewm(span=self.config["signal_period"], adjust=False).mean()

        return "buy" if macd.iloc[-1] > signal_line.iloc[-1] else "sell" if macd.iloc[-1] < signal_line.iloc[-1] else "hold"

# ===== ESTRATEGIA CON IA REAL =====

class IABasedStrategy(Strategy):
    """Estrategia basada en un modelo de IA real."""
    required_config = ["model_path"]

    def __init__(self, name: str, config: Dict[str, Any]):
        super().__init__(name, config)
        self.model = joblib.load(config["model_path"])

    def generate_signal(self, market_data: Dict[str, Any]) -> str:
        features = self._preprocess_features(market_data.get("features", []))
        prediction = self.model.predict([features])[0]
        return "buy" if prediction > 0.6 else "sell" if prediction < 0.4 else "hold"

    def _preprocess_features(self, features: List[float]) -> List[float]:
        return np.array(features[-10:]) if len(features) >= 10 else np.pad(features, (10 - len(features), 0), "constant")

# ===== FACTORY OPTIMIZADA =====

class StrategyFactory:
    """Fábrica dinámica para crear estrategias."""

    _strategies: Dict[str, type] = {}

    @classmethod
    def register_strategy(cls, name: str, strategy_class: type):
        """Registra una nueva estrategia dinámicamente."""
        cls._strategies[name] = strategy_class

    def create_strategy(self, name: str, config: Dict[str, Any]) -> Strategy:
        """Crea una instancia de la estrategia especificada."""
        strategy_class = self._strategies.get(name)
        if not strategy_class:
            raise ValueError(f"Estrategia desconocida: {name}")
        return strategy_class(name, config)

# Registro de estrategias
StrategyFactory.register_strategy("sma_crossover", SMACrossoverStrategy)
StrategyFactory.register_strategy("rsi", RSIStrategy)
StrategyFactory.register_strategy("macd", MACDStrategy)
StrategyFactory.register_strategy("ia_based", IABasedStrategy)

# ===== EJEMPLO DE USO =====

if __name__ == "__main__":
    # Configuración de ejemplo
    config = {
        "sma_crossover": {"short_window": 5, "long_window": 20},
        "rsi": {"rsi_period": 14},
        "macd": {"fast_period": 12, "slow_period": 26, "signal_period": 9},
        "ia_based": {"model_path": "model.pkl"}
    }

    # Datos de mercado simulados
    market_data = {
        "prices": list(np.random.random(50)),
        "features": list(np.random.random(15))
    }

    factory = StrategyFactory()
    sma_strategy = factory.create_strategy("sma_crossover", config["sma_crossover"])
    print(f"Señal SMA: {sma_strategy.generate_signal(market_data)}")






Risk management




import logging
from typing import Dict, Any, Tuple
import numpy as np
import pandas as pd
import asyncio
import time

# Configuración de logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# ===== GESTOR DE RIESGO PRINCIPAL =====
class RiskManager:
    """Manejo de riesgo avanzado para operaciones de trading."""

    def __init__(self, config: Dict[str, Any]):
        self.max_risk_per_trade = config.get("max_risk_per_trade", 0.02)
        self.stop_loss_atr_multiplier = config.get("stop_loss_atr_multiplier", 2.0)
        self.trailing_stop_atr_multiplier = config.get("trailing_stop_atr_multiplier", 1.5)
        self.max_slippage = config.get("max_slippage", 0.001)
        self.logger = logging.getLogger("RiskManager")

    def calculate_position_size(self, capital: float, entry_price: float, atr: float) -> float:
        """Calcula el tamaño de la posición basado en el capital y el ATR."""
        risk_amount = capital * self.max_risk_per_trade
        stop_loss_distance = atr * self.stop_loss_atr_multiplier
        position_size = risk_amount / (stop_loss_distance * entry_price)
        self.logger.info(f"Posición calculada: {position_size} (capital: {capital}, ATR: {atr})")
        return round(position_size, 6)

    def apply_stop_loss(self, entry_price: float, side: str, atr: float) -> float:
        """Calcula el stop-loss dinámico basado en ATR."""
        stop_loss_distance = atr * self.stop_loss_atr_multiplier
        stop_loss = entry_price - stop_loss_distance if side == "buy" else entry_price + stop_loss_distance
        return round(stop_loss, 6)

    def apply_trailing_stop(self, current_price: float, highest_price: float, side: str, atr: float) -> float:
        """Calcula el trailing stop adaptativo basado en ATR."""
        trailing_stop_distance = atr * self.trailing_stop_atr_multiplier
        if side == "buy":
            trailing_stop = max(highest_price - trailing_stop_distance, self.apply_stop_loss(current_price, side, atr))
        else:
            trailing_stop = min(highest_price + trailing_stop_distance, self.apply_stop_loss(current_price, side, atr))
        return round(trailing_stop, 6)

# ===== CONTROLADOR DE SLIPPAGE =====
class SlippageController:
    """Maneja la validación del slippage en cada orden."""

    def __init__(self, base_max_slippage: float, liquidity_factor: float):
        self.base_max_slippage = base_max_slippage
        self.liquidity_factor = liquidity_factor
        self.logger = logging.getLogger("SlippageController")

    def validate_slippage(self, expected_price: float, execution_price: float, liquidity: float) -> bool:
        """Valida el slippage dinámicamente según liquidez."""
        dynamic_max_slippage = self.base_max_slippage * (1 + (self.liquidity_factor / liquidity))
        slippage = abs(execution_price - expected_price) / expected_price
        if slippage > dynamic_max_slippage:
            self.logger.warning(f"Slippage excesivo: {slippage:.6f} (límite: {dynamic_max_slippage:.6f})")
            return False
        return True

# ===== MANEJO DE LIQUIDEZ =====
class LiquidityChecker:
    """Evalúa la liquidez considerando la profundidad del order book."""

    def __init__(self, min_liquidity: float, depth_levels: int):
        self.min_liquidity = min_liquidity
        self.depth_levels = depth_levels
        self.logger = logging.getLogger("LiquidityChecker")

    def check_liquidity(self, order_book: Dict[str, Any]) -> bool:
        """Verifica la liquidez en múltiples niveles del order book."""
        bids = order_book.get("bids", [])[:self.depth_levels]
        asks = order_book.get("asks", [])[:self.depth_levels]
        bid_volume = sum([bid[1] for bid in bids])  # [precio, volumen]
        ask_volume = sum([ask[1] for ask in asks])
        liquidity = min(bid_volume, ask_volume)
        if liquidity >= self.min_liquidity:
            return True
        self.logger.warning(f"Liquidez insuficiente: {liquidity} < {self.min_liquidity}")
        return False

# ===== MANEJO DE FALLAS Y RECUPERACIÓN =====
class FailoverHandler:
    """Maneja fallas y reintentos en múltiples exchanges."""

    def __init__(self, retry_attempts: int = 3, backoff_factor: float = 2.0):
        self.retry_attempts = retry_attempts
        self.backoff_factor = backoff_factor
        self.logger = logging.getLogger("FailoverHandler")

    async def execute_with_failover(self, execute_trade, *args) -> Tuple[bool, Any]:
        """Ejecuta la orden con reintentos y backoff exponencial."""
        for attempt in range(self.retry_attempts):
            try:
                result = await execute_trade(*args)
                return True, result
            except Exception as e:
                wait_time = self.backoff_factor ** attempt
                self.logger.warning(f"Error (intento {attempt + 1}/{self.retry_attempts}): {e}. Esperando {wait_time}s")
                await asyncio.sleep(wait_time)
        return False, "Falló tras múltiples intentos"

# ===== EJEMPLO DE USO ASÍNCRONO =====
async def simulate_trade(price: float) -> float:
    """Simula la ejecución de una orden."""
    await asyncio.sleep(0.1)  # Simula latencia
    if np.random.random() < 0.2:  # 20% de probabilidad de fallo
        raise Exception("Fallo simulado en el exchange")
    return price * 1.001  # Simula ejecución con pequeño slippage

async def main():
    config = {
        "max_risk_per_trade": 0.02,
        "stop_loss_atr_multiplier": 2.0,
        "trailing_stop_atr_multiplier": 1.5,
        "max_slippage": 0.001
    }

    risk_manager = RiskManager(config)
    slippage_controller = SlippageController(base_max_slippage=0.001, liquidity_factor=1.0)
    liquidity_checker = LiquidityChecker(min_liquidity=1000, depth_levels=5)
    failover_handler = FailoverHandler(retry_attempts=3, backoff_factor=2.0)

    # Ejemplo de uso
    capital = 10000
    entry_price = 50000
    atr = 100  # ATR simulado
    trade_size = risk_manager.calculate_position_size(capital, entry_price, atr)
    stop_loss = risk_manager.apply_stop_loss(entry_price, "buy", atr)
    trailing_stop = risk_manager.apply_trailing_stop(50500, 51000, "buy", atr)

    print(f"Tamaño de la posición: {trade_size}")
    print(f"Stop-Loss: {stop_loss}")
    print(f"Trailing Stop: {trailing_stop}")

    # Validación de slippage
    execution_price = 50010
    liquidity = 1500
    slippage_valid = slippage_controller.validate_slippage(entry_price, execution_price, liquidity)
    print(f"Slippage válido: {slippage_valid}")

    # Verificación de liquidez
    order_book = {
        "bids": [[49990, 500], [49980, 400], [49970, 600]],
        "asks": [[50010, 450], [50020, 550], [50030, 700]]
    }
    liquidity_ok = liquidity_checker.check_liquidity(order_book)
    print(f"Liquidez suficiente: {liquidity_ok}")

    # Ejecución con failover
    success, result = await failover_handler.execute_with_failover(simulate_trade, entry_price)
    print(f"Ejecución exitosa: {success}, Resultado: {result}")

if __name__ == "__main__":
    asyncio.run(main())





Market data




import asyncio
import logging
import random
import numpy as np
import pandas as pd
from typing import Dict, List

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

class MarketData:
    """Gestor de datos de mercado con manejo de concurrencia y cálculo de ATR."""

    def __init__(self, api_clients: Dict[str, object], update_interval: float = 5.0, max_concurrent: int = 50):
        self.api_clients = api_clients
        self.update_interval = update_interval
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.data = {}
        self.active_symbols = set()
        self.logger = logging.getLogger("MarketData")

    async def fetch_symbol_data(self, symbol: str, exchange_name: str, client):
        """Obtiene datos del mercado de un símbolo desde un exchange."""
        async with self.semaphore:
            try:
                data = await client.fetch_market_data(symbol)
                if not data or "price" not in data or data["price"] <= 0:
                    self.logger.error(f"Datos inválidos de {exchange_name} para {symbol}")
                    return
                self.data.setdefault(symbol, {})[exchange_name] = data
                self.logger.info(f"Actualizado {symbol} en {exchange_name}: {data['price']}")
            except Exception as e:
                self.logger.warning(f"Error en {exchange_name} para {symbol}: {e}")

    def start_update_loop(self, symbols: List[str]):
        """Inicia la actualización constante de datos de los símbolos dados."""
        self.active_symbols = set(symbols)
        asyncio.create_task(self.update_loop())

    async def update_loop(self):
        """Loop principal para actualizar datos de todos los símbolos activos."""
        while True:
            tasks = [
                self.fetch_symbol_data(symbol, ex, client)
                for symbol in self.active_symbols
                for ex, client in self.api_clients.items()
            ]
            await asyncio.gather(*tasks)
            await asyncio.sleep(self.update_interval)

    def get_price(self, symbol: str, exchange_name: str) -> float:
        return self.data.get(symbol, {}).get(exchange_name, {}).get("price", 0)

    def get_ohlcv(self, symbol: str, exchange_name: str) -> List:
        return self.data.get(symbol, {}).get(exchange_name, {}).get("ohlcv", [])

    def get_atr(self, symbol: str, exchange_name: str, period: int = 14) -> float:
        """Calcula el ATR desde el OHLCV."""
        ohlcv = self.get_ohlcv(symbol, exchange_name)
        if len(ohlcv) < period + 1:
            return 0.0
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        high = df["high"]
        low = df["low"]
        close = df["close"]
        prev_close = close.shift(1)
        tr = pd.concat([
            high - low,
            (high - prev_close).abs(),
            (low - prev_close).abs()
        ], axis=1).max(axis=1)
        atr = tr.rolling(window=period).mean().iloc[-1]
        return round(atr, 6) if not np.isnan(atr) else 0.0

class SlippageController:
    """Valida slippage dinámico basado en ATR."""
    
    def __init__(self, base_max_slippage: float, market_data: MarketData):
        self.base_max_slippage = base_max_slippage
        self.market_data = market_data
        self.logger = logging.getLogger("SlippageController")

    def get_dynamic_slippage(self, symbol: str, exchange_name: str) -> float:
        atr = self.market_data.get_atr(symbol, exchange_name)
        return min(self.base_max_slippage * (1 + atr / 100), 0.01)  # 1% máx

    def validate_slippage(self, entry_price: float, execution_price: float, symbol: str, exchange_name: str) -> bool:
        max_slippage = self.get_dynamic_slippage(symbol, exchange_name)
        real_slippage = abs(execution_price - entry_price) / entry_price
        if real_slippage > max_slippage:
            self.logger.warning(f"Slippage alto en {symbol}: {real_slippage:.6f} > {max_slippage:.6f}")
            return False
        return True

class TradingEngine:
    """Simulación de motor de trading que valida condiciones antes de operar."""

    def __init__(self, market_data: MarketData):
        self.market_data = market_data
        self.logger = logging.getLogger("TradingEngine")

    def execute_trade(self, strategy_name: str, trading_pair: str, side: str, capital: float) -> Dict:
        atr = self.market_data.get_atr(trading_pair, "binance")
        if atr > 0.05:  # Umbral de alta volatilidad
            self.logger.critical(f"ATR elevado en {trading_pair} ({atr}), pausando operación.")
            return {"status": "paused", "reason": "Volatilidad extrema"}
        # Aquí vendría la lógica de ejecución real
        self.logger.info(f"Ejecución de estrategia {strategy_name} en {trading_pair} con ${capital}")
        return {"status": "executed", "exchange": "binance", "price": self.market_data.get_price(trading_pair, "binance")}

# ===== SIMULACIÓN DE CONDICIONES EXTREMAS =====

async def simulate_extreme_conditions(engine: TradingEngine):
    symbol = "BTC/USDT"
    simulated_price = 50000 * (1 + random.uniform(-0.1, 0.1))
    simulated_ohlcv = [[t, 50000, 51000, 49000,
                        50000 * (1 + random.uniform(-0.1, 0.1)), 100]
                       for t in range(100)]
    
    engine.market_data.data[symbol] = {
        "binance": {
            "price": simulated_price,
            "ohlcv": simulated_ohlcv
        }
    }

    result = engine.execute_trade("sma_crossover", symbol, "buy", 1000)
    print(f"Resultado: {result}")

# ===== EJECUCIÓN =====

if __name__ == "__main__":
    class DummyClient:
        async def fetch_market_data(self, symbol):
            return {
                "price": 50000 * (1 + random.uniform(-0.01, 0.01)),
                "ohlcv": [[t, 50000, 51000, 49000, 50000 * (1 + random.uniform(-0.01, 0.01)), 100] for t in range(100)]
            }

    dummy_clients = {"binance": DummyClient()}
    market_data = MarketData(dummy_clients)
    slippage_controller = SlippageController(base_max_slippage=0.001, market_data=market_data)
    engine = TradingEngine(market_data)

    asyncio.run(simulate_extreme_conditions(engine))





Trading





import logging
import asyncio
import random
from typing import Dict, Any, Optional
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor

# Configuración de logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# Simulación de dependencias mínimas
class ExchangeClient:
    def __init__(self, config):
        self.api_key = config["api_key"]
        self.fail_rate = random.random()  # Probabilidad de fallo para simulación

    def get_current_price(self, pair):
        return random.uniform(40000, 60000) if random.random() > self.fail_rate else None

    def place_order(self, pair, side, size):
        if random.random() < self.fail_rate:
            raise Exception("Simulated API failure")
        return {"order_id": "123", "executed_price": self.get_current_price(pair), "size": size}

class ExchangeManager:
    def __init__(self, config):
        self.exchanges = {name: ExchangeClient(conf) for name, conf in config.items()}
        self.failures = {name: 0 for name in config}
        self.max_failures = 5

    def get_best_exchange(self, pair):
        available = [name for name, count in self.failures.items() if count < self.max_failures]
        return random.choice(available) if available else None

    def report_failure(self, name):
        self.failures[name] += 1

class RiskManager:
    def __init__(self, config):
        self.max_risk = config["max_risk_per_trade"]
        self.stop_loss_pct = config["stop_loss_percent"]

    def calculate_position_size(self, capital, price):
        return (capital * self.max_risk) / price if price > 0 else 0

    def apply_stop_loss(self, price, side):
        return price * (1 - self.stop_loss_pct) if side == "buy" else price * (1 + self.stop_loss_pct)

class SlippageController:
    def __init__(self, max_slippage):
        self.max_slippage = max_slippage

    def validate_slippage(self, entry_price, execution_price):
        return abs(execution_price - entry_price) / entry_price <= self.max_slippage if entry_price > 0 else False

class FailoverHandler:
    def __init__(self, retry_attempts):
        self.retries = retry_attempts

    def execute_with_failover(self, func, *args):
        for attempt in range(self.retries + 1):
            try:
                result = func(*args)
                return True, result
            except Exception as e:
                logging.warning(f"Fallo en intento {attempt + 1}/{self.retries + 1}: {e}")
                if attempt == self.retries:
                    return False, str(e)
                asyncio.sleep(1)  # Simula espera entre reintentos

class Strategy:
    def __init__(self, config):
        self.config = config

    def generate_signal(self, market_data):
        return random.choice(["buy", "sell"])  # Simulación simple

class StrategyFactory:
    def create_strategy(self, name, config):
        return Strategy(config)

class MarketData:
    def __init__(self, config):
        self.source = config["source"]

    def get_data(self, pair):
        # Simulación de datos extremos
        prices = [50000 * (1 + random.uniform(-0.5, 1.0)) for _ in range(10)]  # Volatilidad extrema
        return {"prices": prices}

# Motor de Trading Mejorado
class TradingEngine:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.exchange_manager = ExchangeManager(config["exchanges"])
        self.risk_manager = RiskManager(config["risk_management"])
        self.slippage_controller = SlippageController(config["risk_management"]["max_slippage"])
        self.failover_handler = FailoverHandler(config["failover"]["retry_attempts"])
        self.strategy_factory = StrategyFactory()
        self.market_data = MarketData(config["market_data"])
        self.executor = ThreadPoolExecutor(max_workers=10)  # Para operaciones concurrentes
        self.volatility_threshold = 0.1  # Umbral para pausar en volatilidad extrema

    async def execute_trade(self, strategy_name: str, trading_pair: str, side: str, capital: float) -> Dict[str, Any]:
        # Validación de entrada
        if capital <= 0 or not trading_pair or side not in ["buy", "sell"]:
            return {"status": "error", "message": "Parámetros inválidos"}

        # Obtener datos de mercado
        try:
            market_data = await asyncio.to_thread(self.market_data.get_data, trading_pair)
            if not market_data or "prices" not in market_data or not market_data["prices"]:
                return {"status": "error", "message": "Datos de mercado inválidos"}
        except Exception as e:
            logging.error(f"Error obteniendo datos de mercado: {e}")
            return {"status": "error", "message": "Fallo en datos de mercado"}

        # Chequeo de volatilidad extrema
        price_volatility = max(market_data["prices"]) / min(market_data["prices"]) - 1
        if price_volatility > self.volatility_threshold:
            logging.critical(f"Volatilidad extrema detectada ({price_volatility:.2%}). Pausando.")
            return {"status": "paused", "reason": "Volatilidad extrema"}

        # Seleccionar estrategia y generar señal
        strategy = self.strategy_factory.create_strategy(strategy_name, self.config["strategies"][strategy_name])
        signal = strategy.generate_signal(market_data)
        if signal != side:
            logging.warning(f"Estrategia {strategy_name} sugiere {signal}, pero se intentó {side}.")
            return {"status": "canceled", "reason": "Señal no coincide"}

        # Obtener el mejor exchange
        best_exchange = self.exchange_manager.get_best_exchange(trading_pair)
        if not best_exchange:
            logging.error("No se encontró un exchange adecuado.")
            return {"status": "error", "message": "No suitable exchange found"}

        # Calcular tamaño de la orden
        entry_price = market_data["prices"][-1]
        position_size = self.risk_manager.calculate_position_size(capital, entry_price)
        stop_loss = self.risk_manager.apply_stop_loss(entry_price, side)

        # Validar slippage
        execution_price = self.exchange_manager.exchanges[best_exchange].get_current_price(trading_pair)
        if execution_price is None or not self.slippage_controller.validate_slippage(entry_price, execution_price):
            logging.warning(f"Slippage muy alto o precio inválido en {best_exchange}.")
            return {"status": "error", "message": "Slippage demasiado alto"}

        # Ejecutar la orden con failover
        success, result = self.failover_handler.execute_with_failover(
            self.exchange_manager.exchanges[best_exchange].place_order,
            trading_pair, side, position_size
        )

        if success:
            logging.info(f"Orden ejecutada con éxito en {best_exchange}: {result}")
            return {"status": "success", "exchange": best_exchange, "order_details": result}
        else:
            self.exchange_manager.report_failure(best_exchange)
            logging.error("Fallo en la ejecución tras reintentos.")
            return {"status": "error", "message": "Orden no ejecutada"}

    async def stress_test(self, num_trades: int):
        tasks = [
            self.execute_trade("sma_crossover", "BTC/USDT", random.choice(["buy", "sell"]), 1000)
            for _ in range(num_trades)
        ]
        results = await asyncio.gather(*tasks)
        return results

# Configuración y Prueba
if __name__ == "__main__":
    config = {
        "exchanges": {
            "binance": {"api_key": "XXXX", "api_secret": "YYYY"},
            "bybit": {"api_key": "AAAA", "api_secret": "BBBB"},
        },
        "risk_management": {
            "max_risk_per_trade": 0.02,
            "stop_loss_percent": 0.01,
            "trailing_stop": True,
            "trailing_stop_percent": 0.005,
            "max_slippage": 0.001
        },
        "failover": {"retry_attempts": 3},
        "market_data": {"source": "binance"},
        "strategies": {
            "sma_crossover": {"short_window": 5, "long_window": 20},
            "rsi": {"rsi_period": 14},
            "macd": {"fast_period": 12, "slow_period": 26, "signal_period": 9},
        }
    }

    trading_engine = TradingEngine(config)

    # Prueba simple
    result = asyncio.run(trading_engine.execute_trade("sma_crossover", "BTC/USDT", "buy", 1000))
    print("Prueba simple:", result)

    # Prueba de estrés: 100 operaciones simultáneas
    print("\nIniciando prueba de estrés...")
    stress_results = asyncio.run(trading_engine.stress_test(100))
    successes = sum(1 for r in stress_results if r["status"] == "success")
    print(f"Prueba de estrés completada: {successes}/100 operaciones exitosas")




Order manager




import logging
import asyncio
import random
from typing import Dict, Any, Optional
from decimal import Decimal
from concurrent.futures import ThreadPoolExecutor

# Configuración del log
logger = logging.getLogger("OrderManager")
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# Simulación de dependencias mínimas
class ExchangeClient:
    async def place_order(self, symbol, side, amount, price):
        if random.random() < 0.2:  # 20% de fallo simulado
            raise Exception("Simulated API failure")
        await asyncio.sleep(random.uniform(0.1, 0.5))  # Latencia artificial
        return {"order_id": f"ord_{random.randint(1000, 9999)}", "executed_price": price * (1 + random.uniform(-0.05, 0.05))}

    async def cancel_order(self, order_id):
        await asyncio.sleep(0.1)  # Simula latencia
        return True

class ExchangeManager:
    def __init__(self):
        self.exchanges = {"binance": ExchangeClient(), "bybit": ExchangeClient()}
        self.failures = {"binance": 0, "bybit": 0}
        self.max_failures = 5

    def get_best_exchange(self, symbol):
        available = [ex for ex, count in self.failures.items() if count < self.max_failures]
        return random.choice(available) if available else None

    def report_failure(self, exchange_name):
        self.failures[exchange_name] += 1

class MarketData:
    def get_best_price(self, symbol):
        return random.uniform(40000, 60000)  # Precio volátil

    def get_atr(self, symbol, exchange_name):
        return random.uniform(0.01, 0.1)  # ATR simulado con volatilidad alta

    def get_order_book_data(self, symbol, exchange_name):
        price = self.get_best_price(symbol)
        return {"bid": price * 0.99, "ask": price * 1.01}

class RiskManager:
    def calculate_position_size(self, capital, price, atr):
        return (capital * 0.02) / (price * atr) if price > 0 else 0

    def apply_stop_loss(self, price, side, atr):
        return price * (1 - atr) if side == "buy" else price * (1 + atr)

    def apply_trailing_stop(self, price, current_price, side, atr):
        return price * (1 - atr / 2) if side == "buy" else price * (1 + atr / 2)

class SlippageController:
    def __init__(self, max_slippage=0.001):
        self.max_slippage = max_slippage

    def validate_slippage(self, entry_price, execution_price, liquidity):
        slippage = abs(execution_price - entry_price) / entry_price
        return slippage <= self.max_slippage * (1 + liquidity / entry_price)

class FailoverHandler:
    def __init__(self, retry_attempts=3):
        self.retries = retry_attempts

    async def execute_with_failover(self, coro):
        for attempt in range(self.retries + 1):
            try:
                result = await coro()
                return True, result
            except Exception as e:
                logger.warning(f"Fallo en intento {attempt + 1}/{self.retries + 1}: {e}")
                if attempt == self.retries:
                    return False, str(e)
                await asyncio.sleep(1)

# OrderManager Mejorado
class OrderManager:
    def __init__(self,
                 exchange_manager: ExchangeManager,
                 market_data: MarketData,
                 risk_manager: RiskManager,
                 slippage_controller: SlippageController,
                 failover_handler: FailoverHandler,
                 capital: float):
        self.exchange_manager = exchange_manager
        self.market_data = market_data
        self.risk_manager = risk_manager
        self.slippage_controller = slippage_controller
        self.failover_handler = failover_handler
        self.capital = capital
        self.open_orders: Dict[str, Any] = {}
        self.executor = ThreadPoolExecutor(max_workers=20)  # Para concurrencia
        self.volatility_threshold = 0.05  # Pausar si ATR > 5%
        self.lock = asyncio.Lock()  # Evitar condiciones de carrera

    async def place_order(self,
                          symbol: str,
                          side: str,
                          strategy_name: str,
                          base_currency: str = "USDT") -> Dict[str, Any]:
        # Validación de entrada
        if not symbol or side not in ["buy", "sell"] or self.capital <= 0:
            return {"status": "error", "message": "Parámetros inválidos"}

        exchange_name = self.exchange_manager.get_best_exchange(symbol)
        if not exchange_name:
            return {"status": "error", "message": "No suitable exchange found"}

        client = self.exchange_manager.exchanges[exchange_name]

        # Obtener datos de mercado
        price = await asyncio.to_thread(self.market_data.get_best_price, symbol)
        atr = await asyncio.to_thread(self.market_data.get_atr, symbol, exchange_name)

        if not price or not atr or price <= 0:
            return {"status": "error", "message": "Invalid market data"}

        # Pausar en volatilidad extrema
        if atr > self.volatility_threshold:
            logger.critical(f"Volatilidad extrema (ATR: {atr}). Pausando órdenes.")
            return {"status": "paused", "reason": "Volatilidad extrema"}

        size = self.risk_manager.calculate_position_size(self.capital, price, atr)
        stop_loss = self.risk_manager.apply_stop_loss(price, side, atr)
        trailing_stop = self.risk_manager.apply_trailing_stop(price, price, side, atr)

        async def execute_trade():
            return await client.place_order(symbol=symbol, side=side, amount=size, price=price)

        success, result = await self.failover_handler.execute_with_failover(execute_trade)

        if not success:
            self.exchange_manager.report_failure(exchange_name)
            return {"status": "error", "message": result}

        execution_price = result.get("executed_price", price)
        order_id = result.get("order_id", "unknown")

        # Validación de slippage
        order_book = self.market_data.get_order_book_data(symbol, exchange_name)
        liquidity = max(order_book.get("bid", 1), order_book.get("ask", 1))
        if not self.slippage_controller.validate_slippage(price, execution_price, liquidity):
            logger.warning(f"Slippage alto. Cancelando orden {order_id}")
            await client.cancel_order(order_id)
            return {"status": "error", "message": "Slippage demasiado alto"}

        # Guardar orden con lock para concurrencia
        async with self.lock:
            self.open_orders[order_id] = {
                "symbol": symbol,
                "exchange": exchange_name,
                "side": side,
                "amount": size,
                "entry_price": execution_price,
                "stop_loss": stop_loss,
                "trailing_stop": trailing_stop,
                "strategy": strategy_name,
                "status": "open"
            }

        logger.info(f"Orden ejecutada: {self.open_orders[order_id]}")
        return {"status": "success", "order": self.open_orders[order_id]}

    async def monitor_trailing_stops(self):
        """Monitorea y ajusta trailing stops en tiempo real."""
        while True:
            async with self.lock:
                for order_id, order in list(self.open_orders.items()):
                    if order["status"] != "open":
                        continue
                    current_price = self.market_data.get_best_price(order["symbol"])
                    atr = self.market_data.get_atr(order["symbol"], order["exchange"])
                    new_trailing = self.risk_manager.apply_trailing_stop(
                        order["entry_price"], current_price, order["side"], atr
                    )
                    if (order["side"] == "buy" and current_price < new_trailing) or \
                       (order["side"] == "sell" and current_price > new_trailing):
                        logger.info(f"Cerrando orden {order_id} por trailing stop.")
                        await self.cancel_order(order_id)
                    else:
                        order["trailing_stop"] = new_trailing
            await asyncio.sleep(1)

    def get_open_orders(self) -> Dict[str, Any]:
        return self.open_orders

    async def cancel_order(self, order_id: str) -> bool:
        order = self.open_orders.get(order_id)
        if not order or order["status"] != "open":
            return False

        exchange_name = order["exchange"]
        client = self.exchange_manager.exchanges[exchange_name]
        await client.cancel_order(order_id)
        async with self.lock:
            order["status"] = "cancelled"
        logger.info(f"Orden cancelada: {order_id}")
        return True

    def update_capital(self, new_capital: float):
        if new_capital < 0:
            raise ValueError("Capital no puede ser negativo")
        self.capital = new_capital
        logger.info(f"Capital actualizado: ${new_capital:.2f}")

    async def stress_test(self, num_orders: int):
        tasks = [
            self.place_order("BTC/USDT", random.choice(["buy", "sell"]), "sma_crossover")
            for _ in range(num_orders)
        ]
        results = await asyncio.gather(*tasks)
        return results

# Prueba
if __name__ == "__main__":
    exchange_manager = ExchangeManager()
    market_data = MarketData()
    risk_manager = RiskManager()
    slippage_controller = SlippageController()
    failover_handler = FailoverHandler()
    order_manager = OrderManager(exchange_manager, market_data, risk_manager,
                                 slippage_controller, failover_handler, 10000)

    # Iniciar monitoreo de trailing stops
    asyncio.create_task(order_manager.monitor_trailing_stops())

    # Prueba simple
    result = asyncio.run(order_manager.place_order("BTC/USDT", "buy", "sma_crossover"))
    print("Prueba simple:", result)

    # Prueba de estrés
    print("\nIniciando prueba de estrés...")
    stress_results = asyncio.run(order_manager.stress_test(100))
    successes = sum(1 for r in stress_results if r["status"] == "success")
    print(f"Prueba de estrés completada: {successes}/100 operaciones exitosas")





Strategy orcherstator





import logging
import time
import asyncio
import random
from typing import Dict, Any, List
from collections import deque
from concurrent.futures import ThreadPoolExecutor

# Configuración de logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# Simulación de dependencias mínimas
class Strategy:
    def __init__(self, name, config):
        self.name = name
        self.config = config

    def generate_signal(self, market):
        return random.choice(["buy", "sell", "hold"])  # Simulación simple

class StrategyFactory:
    def create_strategy(self, name, config):
        return Strategy(name, config)

class MarketData:
    def get_data(self, trading_pair):
        if random.random() < 0.1:  # 10% de fallo simulado
            return None
        # Simulación de datos extremos
        return {"prices": [50000 * (1 + random.uniform(-0.5, 0.5)) for _ in range(10)]}

class PerformanceTracker:
    def __init__(self):
        self.scores = {}

    def log_performance(self, name, score):
        self.scores[name] = score

    def get_last_score(self, name):
        return self.scores.get(name)

class PaperTrader:
    def __init__(self, market_data, capital):
        self.market_data = market_data
        self.capital = capital

    def simulate(self, strategy, trading_pair):
        market = self.market_data.get_data(trading_pair)
        if not market:
            return {"performance_score": 0}
        signal = strategy.generate_signal(market)
        # Simulación simple de rendimiento
        return {"performance_score": random.uniform(0, 1) if signal != "hold" else 0.2}

class RiskManager:
    def __init__(self, config):
        self.config = config

# StrategyOrchestrator Mejorado
class StrategyOrchestrator:
    def __init__(self, strategy_configs: Dict[str, Dict[str, Any]], 
                 market_data, capital: float, config: Dict[str, Any]):
        self.strategy_configs = strategy_configs
        self.market_data = market_data
        self.capital = capital
        self.config = config
        self.active_strategy_name = list(strategy_configs.keys())[0]
        self.factory = StrategyFactory()
        self.performance = PerformanceTracker()
        self.paper_trader = PaperTrader(self.market_data, self.capital)
        self.risk_manager = RiskManager(config.get("risk_management", {}))
        self.strategy_instances = {
            name: self.factory.create_strategy(name, cfg)
            for name, cfg in strategy_configs.items()
        }
        self.history = deque(maxlen=1000)  # Historial limitado
        self.executor = ThreadPoolExecutor(max_workers=10)  # Evaluación paralela
        self.min_performance_threshold = config.get("min_performance_threshold", 0.4)
        self.eval_cooldown = 60  # Cooldown en segundos para reevaluaciones
        self.last_eval_time = 0
        self.eval_failures = 0
        self.max_eval_failures = 5  # Circuit breaker

    async def evaluate_strategies(self, trading_pair: str) -> str:
        """Evalúa todas las estrategias y selecciona la mejor."""
        if time.time() - self.last_eval_time < self.eval_cooldown:
            logging.info("Evaluación en cooldown. Usando estrategia activa.")
            return self.active_strategy_name

        if self.eval_failures >= self.max_eval_failures:
            logging.critical("Demasiados fallos en evaluación. Manteniendo estrategia activa.")
            return self.active_strategy_name

        scores = {}
        tasks = []
        for name, strategy in self.strategy_instances.items():
            tasks.append(self._simulate_strategy(name, strategy, trading_pair))

        try:
            results = await asyncio.gather(*tasks)
            for name, result in results:
                scores[name] = result.get("performance_score", 0)
                self.performance.log_performance(name, scores[name])
        except Exception as e:
            self.eval_failures += 1
            logging.error(f"Fallo en evaluación de estrategias: {e}")
            return self.active_strategy_name

        if not scores:
            self.eval_failures += 1
            return self.active_strategy_name

        best_strategy = max(scores, key=scores.get)
        logging.info(f"Estrategia más efectiva: {best_strategy} (score: {scores[best_strategy]:.4f})")
        self.last_eval_time = time.time()
        self.eval_failures = 0  # Resetear fallos tras éxito
        return best_strategy

    async def _simulate_strategy(self, name: str, strategy, trading_pair: str):
        """Simula una estrategia en un hilo separado."""
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(self.executor, self.paper_trader.simulate, strategy, trading_pair)
        return name, result

    async def get_signal(self, trading_pair: str) -> str:
        """Obtiene señal de la mejor estrategia en este momento."""
        try:
            market = self.market_data.get_data(trading_pair)
            if not market or not market.get("prices"):
                logging.warning("Datos de mercado no disponibles o inválidos.")
                return "hold"

            # Re-evaluar si el rendimiento es bajo
            current_perf = self.performance.get_last_score(self.active_strategy_name)
            if current_perf is not None and current_perf < self.min_performance_threshold:
                logging.warning(f"Bajo rendimiento de {self.active_strategy_name} ({current_perf:.2f}). Reevaluando...")
                self.active_strategy_name = await self.evaluate_strategies(trading_pair)

            strategy = self.strategy_instances[self.active_strategy_name]
            signal = strategy.generate_signal(market)
            logging.info(f"Señal generada por {self.active_strategy_name}: {signal}")

            # Verificar volatilidad extrema
            volatility = max(market["prices"]) / min(market["prices"]) - 1
            if volatility > 0.3:  # Pausar si volatilidad > 30%
                logging.critical(f"Volatilidad extrema detectada ({volatility:.2%}). Señal forzada a 'hold'.")
                signal = "hold"

            self.history.append((time.time(), self.active_strategy_name, signal))
            return signal

        except Exception as e:
            logging.error(f"Error en StrategyOrchestrator: {e}")
            return "hold"

    def force_change_strategy(self, new_name: str):
        if new_name in self.strategy_instances:
            self.active_strategy_name = new_name
            logging.info(f"Estrategia cambiada manualmente a: {new_name}")
        else:
            logging.warning(f"Estrategia {new_name} no está registrada.")

    def get_active_strategy(self) -> str:
        return self.active_strategy_name

    def get_strategy_history(self) -> List:
        return list(self.history)

    async def stress_test(self, trading_pairs: List[str], num_iterations: int):
        """Prueba de estrés con múltiples pares y señales."""
        tasks = []
        for _ in range(num_iterations):
            for pair in trading_pairs:
                tasks.append(self.get_signal(pair))
        results = await asyncio.gather(*tasks)
        signals = {"buy": 0, "sell": 0, "hold": 0}
        for signal in results:
            signals[signal] += 1
        return signals

# Prueba
if __name__ == "__main__":
    config = {
        "min_performance_threshold": 0.4,
        "risk_management": {}
    }
    strategy_configs = {
        "sma_crossover": {"short_window": 5, "long_window": 20},
        "rsi": {"period": 14},
        "macd": {"fast": 12, "slow": 26}
    }
    market_data = MarketData()
    orchestrator = StrategyOrchestrator(strategy_configs, market_data, 10000, config)

    # Prueba simple
    signal = asyncio.run(orchestrator.get_signal("BTC/USDT"))
    print(f"Señal simple: {signal}")

    # Prueba de estrés
    print("\nIniciando prueba de estrés...")
    trading_pairs = ["BTC/USDT", "ETH/USDT", "XRP/USDT"]
    stress_results = asyncio.run(orchestrator.stress_test(trading_pairs, 50))
    print(f"Resultados de estrés: {stress_results}")






Performance tracker




import logging
import asyncio
import time
from typing import Dict, List, Optional
from datetime import datetime
from collections import deque
from concurrent.futures import ThreadPoolExecutor
import json
import os

# Configuración de logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

class PerformanceTracker:
    """
    Rastrea el rendimiento de las estrategias a lo largo del tiempo.
    Guarda el puntaje de rendimiento más reciente y el historial de evaluaciones.
    """

    def __init__(self, max_history: int = 1000, persist_path: Optional[str] = None):
        self.scores: Dict[str, float] = {}  # Último rendimiento de cada estrategia
        self.history: Dict[str, deque] = {}  # Historial completo
        self.max_history = max_history
        self.persist_path = persist_path  # Ruta para persistencia en disco
        self.lock = asyncio.Lock()  # Bloqueo para concurrencia
        self.logger = logging.getLogger("PerformanceTracker")
        self.executor = ThreadPoolExecutor(max_workers=10)  # Para operaciones I/O
        self.max_strategies = 10000  # Límite de estrategias
        self.cleanup_threshold = 0.9  # Limpieza cuando se alcanza 90% de max_strategies
        if persist_path and os.path.exists(persist_path):
            self._load_from_disk()

    async def log_performance(self, strategy_name: str, score: float):
        """
        Registra un nuevo puntaje de rendimiento para una estrategia.
        """
        if not isinstance(strategy_name, str) or not strategy_name.strip():
            self.logger.error("Nombre de estrategia inválido.")
            raise ValueError("Strategy name must be a non-empty string")
        if not isinstance(score, (int, float)) or not 0 <= score <= 1:
            self.logger.error(f"Puntaje inválido: {score}")
            raise ValueError("Score must be a number between 0 and 1")

        async with self.lock:
            self.scores[strategy_name] = score
            if strategy_name not in self.history:
                if len(self.scores) >= self.max_strategies * self.cleanup_threshold:
                    await self._cleanup_inactive_strategies()
                self.history[strategy_name] = deque(maxlen=self.max_history)
            self.history[strategy_name].append({
                "timestamp": datetime.utcnow().isoformat(),
                "score": score
            })
            self.logger.info(f"Rendimiento registrado: {strategy_name} → {score:.4f}")

            # Persistencia en disco
            if self.persist_path:
                await self._save_to_disk()

    async def get_last_score(self, strategy_name: str) -> Optional[float]:
        """
        Retorna el último puntaje de una estrategia.
        """
        if not isinstance(strategy_name, str) or not strategy_name.strip():
            return None
        async with self.lock:
            return self.scores.get(strategy_name)

    async def get_history(self, strategy_name: str) -> List[Dict[str, Any]]:
        """
        Retorna el historial completo de rendimiento para una estrategia.
        """
        if not isinstance(strategy_name, str) or not strategy_name.strip():
            return []
        async with self.lock:
            return list(self.history.get(strategy_name, []))

    async def get_all_strategies(self) -> List[str]:
        """
        Retorna la lista de estrategias registradas.
        """
        async with self.lock:
            return list(self.scores.keys())

    async def _cleanup_inactive_strategies(self):
        """Elimina estrategias con puntajes antiguos o bajos."""
        current_time = datetime.utcnow()
        async with self.lock:
            to_remove = []
            for strategy, hist in self.history.items():
                if not hist or (datetime.fromisoformat(hist[-1]["timestamp"]) < 
                                current_time - timedelta(days=7)):
                    to_remove.append(strategy)
            for strategy in to_remove:
                self.logger.info(f"Eliminando estrategia inactiva: {strategy}")
                del self.scores[strategy]
                del self.history[strategy]

    async def _save_to_disk(self):
        """Guarda el estado en disco."""
        loop = asyncio.get_event_loop()
        data = {
            "scores": self.scores,
            "history": {k: list(v) for k, v in self.history.items()}
        }
        await loop.run_in_executor(self.executor, self._write_to_file, data)

    def _write_to_file(self, data):
        with open(self.persist_path, "w") as f:
            json.dump(data, f)

    def _load_from_disk(self):
        """Carga el estado desde disco."""
        try:
            with open(self.persist_path, "r") as f:
                data = json.load(f)
            self.scores = data["scores"]
            self.history = {k: deque(v, maxlen=self.max_history) for k, v in data["history"].items()}
            self.logger.info("Estado cargado desde disco.")
        except Exception as e:
            self.logger.error(f"Error al cargar desde disco: {e}")

    async def stress_test(self, num_strategies: int, num_logs_per_strategy: int):
        """Prueba de estrés con registro masivo y accesos concurrentes."""
        tasks = []
        strategy_names = [f"strategy_{i}" for i in range(num_strategies)]

        # Registro masivo
        for name in strategy_names:
            for _ in range(num_logs_per_strategy):
                tasks.append(self.log_performance(name, random.uniform(0, 1)))

        # Accesos concurrentes
        for name in strategy_names:
            tasks.append(self.get_last_score(name))
            tasks.append(self.get_history(name))
        tasks.append(self.get_all_strategies())

        start_time = time.time()
        await asyncio.gather(*tasks)
        elapsed = time.time() - start_time
        self.logger.info(f"Prueba de estrés completada en {elapsed:.2f}s")

# Prueba
if __name__ == "__main__":
    from datetime import timedelta
    tracker = PerformanceTracker(max_history=1000, persist_path="performance.json")

    # Prueba simple
    asyncio.run(tracker.log_performance("sma_crossover", 0.75))
    last_score = asyncio.run(tracker.get_last_score("sma_crossover"))
    history = asyncio.run(tracker.get_history("sma_crossover"))
    print(f"Último puntaje: {last_score}")
    print(f"Historial: {history}")

    # Prueba de estrés
    print("\nIniciando prueba de estrés...")
    asyncio.run(tracker.stress_test(num_strategies=100, num_logs_per_strategy=100))

Solo agregale eso de la base de datos bb






Balance Manager





import logging
import asyncio
import random
from typing import Dict, Any, Optional
from datetime import datetime
from collections import defaultdict, deque
from concurrent.futures import ThreadPoolExecutor
import json
import os
from asyncio import Semaphore

# Logging básico
logger = logging.getLogger("BalanceManager")
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# Simulación de API Client
class SimulatedClient:
    async def get_balances(self):
        await asyncio.sleep(random.uniform(0.1, 2))  # Latencia extrema
        if random.random() < 0.3:  # 30% de fallo
            raise Exception("Simulated API failure")
        return {f"{random.choice(['USDT', 'BTC', 'ETH'])}": random.uniform(0, 1000) for _ in range(random.randint(1, 10))}

class BalanceManager:
    def __init__(self, api_clients: Dict[str, Any], base_currency: str = "USDT", persist_path: Optional[str] = "balances.json"):
        self.api_clients = api_clients
        self.base_currency = base_currency
        self.balances: Dict[str, Dict[str, float]] = defaultdict(dict)
        self.history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))  # Historial limitado
        self.lock = asyncio.Lock()
        self.executor = ThreadPoolExecutor(max_workers=50)  # Para operaciones concurrentes
        self.persist_path = persist_path
        self.failure_counts = defaultdict(int)
        self.max_failures = 5  # Circuit breaker
        self.semaphore = Semaphore(100)  # Limita concurrencia
        self.min_operational_exchanges = 1  # Mínimo para seguir funcionando
        if persist_path and os.path.exists(persist_path):
            self._load_from_disk()

    async def update_balances(self):
        """Actualiza balances en todos los exchanges en paralelo."""
        async with self.lock:
            tasks = []
            operational_exchanges = 0
            for exchange_name, client in self.api_clients.items():
                if self.failure_counts[exchange_name] >= self.max_failures:
                    logger.warning(f"{exchange_name} en circuit breaker. Saltando.")
                    continue
                operational_exchanges += 1
                tasks.append(self._fetch_balance(exchange_name, client))

            if operational_exchanges < self.min_operational_exchanges:
                logger.critical("No hay suficientes exchanges operativos. Pausando actualizaciones.")
                return

            results = await asyncio.gather(*tasks, return_exceptions=True)
            for exchange_name, result in zip([e for e in self.api_clients if self.failure_counts[e] < self.max_failures], results):
                if isinstance(result, Exception):
                    self.failure_counts[exchange_name] += 1
                    logger.warning(f"Error en {exchange_name}: {result}")
                else:
                    self.balances[exchange_name] = result
                    self.history[exchange_name].append({
                        "timestamp": datetime.utcnow().isoformat(),
                        "balances": result
                    })
                    self.failure_counts[exchange_name] = 0  # Resetear si éxito
                    logger.info(f"[{exchange_name}] Balance actualizado: {result}")

            if self.persist_path:
                await self._save_to_disk()

    async def _fetch_balance(self, exchange_name: str, client):
        """Obtiene balance con límite de concurrencia."""
        async with self.semaphore:
            return await client.get_balances()

    async def get_balance(self, exchange: str, symbol: str) -> float:
        """Retorna el balance actual de un símbolo específico."""
        if not exchange or not symbol:
            return 0.0
        async with self.lock:
            return self.balances.get(exchange, {}).get(symbol.upper(), 0.0)

    async def get_total_balance_usdt(self, price_feed: Dict[str, float]) -> float:
        """Calcula el balance total estimado en USDT."""
        if not price_feed:
            logger.warning("Price feed vacío. Retornando 0.")
            return 0.0
        total = 0.0
        async with self.lock:
            for exchange, symbols in self.balances.items():
                for symbol, amount in symbols.items():
                    if symbol == self.base_currency:
                        total += amount
                    elif symbol in price_feed and price_feed[symbol] > 0:
                        total += amount * price_feed[symbol]
                    else:
                        logger.debug(f"Precio no disponible para {symbol} en {exchange}")
        return round(total, 4)

    def get_balance_snapshot(self) -> Dict[str, Dict[str, float]]:
        """Devuelve una copia actual del estado de balances."""
        return {ex: dict(bals) for ex, bals in self.balances.items()}

    def get_balance_history(self, exchange: str) -> list:
        """Retorna el historial de balances para un exchange."""
        return list(self.history.get(exchange, []))

    async def start_balance_updater(self, interval: int = 30):
        """Inicia actualización automática de balances."""
        while True:
            await self.update_balances()
            await asyncio.sleep(interval)

    async def _save_to_disk(self):
        """Guarda balances en disco."""
        loop = asyncio.get_event_loop()
        data = {
            "balances": self.balances,
            "history": {k: list(v) for k, v in self.history.items()}
        }
        await loop.run_in_executor(self.executor, self._write_to_file, data)

    def _write_to_file(self, data):
        with open(self.persist_path, "w") as f:
            json.dump(data, f)

    def _load_from_disk(self):
        """Carga balances desde disco."""
        try:
            with open(self.persist_path, "r") as f:
                data = json.load(f)
            self.balances = defaultdict(dict, data["balances"])
            self.history = defaultdict(lambda: deque(maxlen=1000), 
                                     {k: deque(v, maxlen=1000) for k, v in data["history"].items()})
            logger.info("Balances cargados desde disco.")
        except Exception as e:
            logger.error(f"Error al cargar desde disco: {e}")

    async def stress_test(self, num_exchanges: int, num_iterations: int):
        """Prueba de estrés con múltiples exchanges y actualizaciones."""
        # Simular muchos exchanges
        self.api_clients = {f"exchange_{i}": SimulatedClient() for i in range(num_exchanges)}
        tasks = [self.update_balances() for _ in range(num_iterations)]
        
        # Simular price feed volátil
        price_feed = {"BTC": random.uniform(20000, 80000), "ETH": random.uniform(1000, 5000), "USDT": 1.0}
        
        start_time = time.time()
        await asyncio.gather(*tasks)
        total_usdt = await self.get_total_balance_usdt(price_feed)
        elapsed = time.time() - start_time
        logger.info(f"Prueba de estrés completada en {elapsed:.2f}s. Total USDT: {total_usdt}")

# Prueba
if __name__ == "__main__":
    api_clients = {"binance": SimulatedClient(), "bybit": SimulatedClient()}
    balance_manager = BalanceManager(api_clients)

    # Prueba simple
    asyncio.run(balance_manager.update_balances())
    price_feed = {"BTC": 50000, "ETH": 3000, "USDT": 1.0}
    total = asyncio.run(balance_manager.get_total_balance_usdt(price_feed))
    print(f"Total USDT: {total}")
    print(f"Snapshot: {balance_manager.get_balance_snapshot()}")

    # Prueba de ultra estrés
    print("\nIniciando prueba de ultra estrés...")
    asyncio.run(balance_manager.stress_test(num_exchanges=1000, num_iterations=10))



Inversionistas



import json
import logging
import os
import asyncio
from typing import Dict, List, Optional
from datetime import datetime
from collections import defaultdict, deque
from concurrent.futures import ThreadPoolExecutor
from decimal import Decimal, ROUND_HALF_UP

# Logging
logger = logging.getLogger("InversionistasManager")
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

class InversionistasManager:
    def __init__(self, archivo_datos: str = "data/inversionistas.json", max_history: int = 1000):
        self.archivo_datos = archivo_datos
        self.inversionistas: Dict[str, Dict[str, Any]] = {}
        self.total_inversion = Decimal('0.0')
        self.lock = asyncio.Lock()
        self.executor = ThreadPoolExecutor(max_workers=10)  # Para I/O asíncrono
        self.max_history = max_history  # Límite de historial por inversionista
        self.backup_file = f"{archivo_datos}.bak"  # Archivo de respaldo
        if os.path.exists(self.archivo_datos):
            self._cargar_datos()
        else:
            self._guardar_datos()

    async def agregar_inversionista(self, nombre: str, telefono: str, correo: str, capital: float):
        if not nombre or not isinstance(nombre, str) or not nombre.strip():
            raise ValueError("Nombre debe ser una cadena no vacía")
        if not isinstance(capital, (int, float)) or capital <= 0:
            raise ValueError("Capital debe ser un número positivo")
        if not telefono or not correo:  # Validación básica
            raise ValueError("Teléfono y correo son requeridos")

        async with self.lock:
            if nombre in self.inversionistas:
                logger.warning(f"{nombre} ya está registrado. Usa actualizar_inversion().")
                return
            self.inversionistas[nombre] = {
                "telefono": telefono,
                "correo": correo,
                "capital": Decimal(str(capital)),
                "historial": deque(maxlen=self.max_history),
                "ganancias": Decimal('0.0')
            }
            self.total_inversion += Decimal(str(capital))
            await self._guardar_datos()
            logger.info(f"Inversionista agregado: {nombre} con ${capital:.2f}")

    async def actualizar_inversion(self, nombre: str, capital_adicional: float):
        if nombre not in self.inversionistas:
            raise KeyError(f"Inversionista {nombre} no encontrado")
        if not isinstance(capital_adicional, (int, float)) or capital_adicional <= 0:
            raise ValueError("El capital adicional debe ser mayor que cero")

        async with self.lock:
            self.inversionistas[nombre]["capital"] += Decimal(str(capital_adicional))
            self.total_inversion += Decimal(str(capital_adicional))
            await self._guardar_datos()
            logger.info(f"{nombre} aumentó su inversión en ${capital_adicional:.2f}")

    async def registrar_ganancia(self, monto_total: float):
        if not isinstance(monto_total, (int, float)) or monto_total <= 0:
            logger.warning("Monto total inválido. No se registran ganancias.")
            return

        monto_total_dec = Decimal(str(monto_total))
        async with self.lock:
            if self.total_inversion <= 0:
                logger.error("Total invertido es cero. No se puede distribuir ganancia.")
                return
            for nombre, datos in self.inversionistas.items():
                porcentaje = datos["capital"] / self.total_inversion
                ganancia = (monto_total_dec * porcentaje).quantize(Decimal('0.0001'), rounding=ROUND_HALF_UP)
                datos["ganancias"] += ganancia
                datos["historial"].append({
                    "fecha": datetime.utcnow().isoformat(),
                    "ganancia": float(ganancia)  # Convertir a float para JSON
                })
            await self._guardar_datos()
            logger.info(f"Ganancia total de ${monto_total:.2f} distribuida entre inversionistas.")

    async def obtener_resumen(self) -> List[Dict[str, Any]]:
        async with self.lock:
            resumen = []
            for nombre, datos in self.inversionistas.items():
                porcentaje = (datos["capital"] / self.total_inversion * 100) if self.total_inversion > 0 else Decimal('0')
                resumen.append({
                    "nombre": nombre,
                    "capital": float(datos["capital"].quantize(Decimal('0.01'))),
                    "ganancias": float(datos["ganancias"].quantize(Decimal('0.01'))),
                    "porcentaje": float(porcentaje.quantize(Decimal('0.01')))
                })
            return resumen

    async def obtener_historial(self, nombre: str) -> List[Dict[str, Any]]:
        async with self.lock:
            if nombre not in self.inversionistas:
                return []
            return list(self.inversionistas[nombre]["historial"])

    async def obtener_inversionista(self, nombre: str) -> Optional[Dict[str, Any]]:
        async with self.lock:
            if nombre in self.inversionistas:
                datos = self.inversionistas[nombre]
                return {
                    "telefono": datos["telefono"],
                    "correo": datos["correo"],
                    "capital": float(datos["capital"]),
                    "ganancias": float(datos["ganancias"]),
                    "historial": list(datos["historial"])
                }
            return None

    async def get_total_invertido(self) -> float:
        async with self.lock:
            return float(self.total_inversion.quantize(Decimal('0.01')))

    async def _guardar_datos(self):
        os.makedirs(os.path.dirname(self.archivo_datos), exist_ok=True)
        loop = asyncio.get_event_loop()
        data = {
            nombre: {
                "telefono": datos["telefono"],
                "correo": datos["correo"],
                "capital": str(datos["capital"]),  # Decimal a string para JSON
                "historial": list(datos["historial"]),
                "ganancias": str(datos["ganancias"])
            } for nombre, datos in self.inversionistas.items()
        }
        # Guardar en archivo principal y respaldo
        await loop.run_in_executor(self.executor, self._write_to_file, self.archivo_datos, data)
        await loop.run_in_executor(self.executor, self._write_to_file, self.backup_file, data)

    def _write_to_file(self, filepath: str, data: Dict):
        try:
            with open(filepath, "w") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Error al guardar en {filepath}: {e}")
            raise

    def _cargar_datos(self):
        try:
            with open(self.archivo_datos, "r") as f:
                data = json.load(f)
            self.inversionistas = {
                nombre: {
                    "telefono": datos["telefono"],
                    "correo": datos["correo"],
                    "capital": Decimal(datos["capital"]),
                    "historial": deque(datos["historial"], maxlen=self.max_history),
                    "ganancias": Decimal(datos["ganancias"])
                } for nombre, datos in data.items()
            }
            self.total_inversion = sum(d["capital"] for d in self.inversionistas.values())
            logger.info("Datos cargados exitosamente.")
        except Exception as e:
            logger.error(f"Error al cargar datos: {e}. Intentando respaldo...")
            self._cargar_respaldo()

    def _cargar_respaldo(self):
        if os.path.exists(self.backup_file):
            try:
                with open(self.backup_file, "r") as f:
                    data = json.load(f)
                self.inversionistas = {
                    nombre: {
                        "telefono": datos["telefono"],
                        "correo": datos["correo"],
                        "capital": Decimal(datos["capital"]),
                        "historial": deque(datos["historial"], maxlen=self.max_history),
                        "ganancias": Decimal(datos["ganancias"])
                    } for nombre, datos in data.items()
                }
                self.total_inversion = sum(d["capital"] for d in self.inversionistas.values())
                logger.info("Datos cargados desde respaldo.")
            except Exception as e:
                logger.critical(f"Error al cargar respaldo: {e}. Iniciando con datos vacíos.")
                self.inversionistas = {}
                self.total_inversion = Decimal('0.0')

    async def stress_test(self, num_investors: int, num_ganancias: int):
        """Prueba de estrés con muchos inversionistas y ganancias."""
        tasks = []
        # Agregar inversionistas concurrentemente
        for i in range(num_investors):
            tasks.append(self.agregar_inversionista(
                f"Investor_{i}", f"+123{i:06d}", f"inv{i}@example.com", random.uniform(100, 10000)
            ))
        
        # Actualizar inversiones
        for i in range(num_investors // 2):
            tasks.append(self.actualizar_inversion(f"Investor_{i}", random.uniform(50, 5000)))
        
        # Registrar ganancias masivas
        for _ in range(num_ganancias):
            tasks.append(self.registrar_ganancia(random.uniform(1000, 100000)))

        start_time = time.time()
        await asyncio.gather(*tasks, return_exceptions=True)
        elapsed = time.time() - start_time

        resumen = await self.obtener_resumen()
        total = await self.get_total_invertido()
        logger.info(f"Prueba de estrés completada en {elapsed:.2f}s. Total invertido: ${total:.2f}")
        print(f"Resumen (primeros 5): {resumen[:5]}")

# ==== Prueba Rápida ====
if __name__ == "__main__":
    import random
    manager = InversionistasManager()

    # Prueba simple
    asyncio.run(manager.agregar_inversionista("Carlos", "+123456789", "carlos@example.com", 500))
    asyncio.run(manager.actualizar_inversion("Carlos", 250))
    asyncio.run(manager.registrar_ganancia(300))
    resumen = asyncio.run(manager.obtener_resumen())
    print("Resumen de inversión:", resumen)

    # Prueba de estrés
    print("\nIniciando prueba de estrés...")
    asyncio.run(manager.stress_test(num_investors=1000, num_ganancias=100))





Security





import base64
import hashlib
import hmac
import asyncio
from typing import Tuple
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Util.Padding import pad, unpad
import logging

# Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")
logger = logging.getLogger("AESCipher")

class AESCipher:
    """Cifra y descifra datos sensibles usando AES-GCM o AES-CBC + HMAC con derivación segura de clave."""
    
    def __init__(self, key: str, use_gcm: bool = True, salt: Optional[bytes] = None):
        self.bs = AES.block_size  # 16 bytes
        self.use_gcm = use_gcm  # AES-GCM por defecto, más seguro
        self.salt = salt if salt else get_random_bytes(16)  # Salt único por instancia
        # Derivar clave con PBKDF2 (más seguro que SHA-256 directo)
        self.key = PBKDF2(key.encode(), self.salt, dkLen=32, count=100000, 
                         prf=lambda p, s: hmac.new(p, s, hashlib.sha256).digest())
        self.hmac_key = PBKDF2(key.encode(), self.salt + b"hmac", dkLen=32, count=100000,
                              prf=lambda p, s: hmac.new(p, s, hashlib.sha256).digest())

    def encrypt(self, raw: str) -> str:
        """Cifra datos con AES-GCM o AES-CBC + HMAC."""
        if not isinstance(raw, str) or not raw.strip():
            raise ValueError("Datos a cifrar deben ser una cadena no vacía")

        if self.use_gcm:
            return self._encrypt_gcm(raw)
        else:
            return self._encrypt_cbc_hmac(raw)

    def decrypt(self, enc: str) -> str:
        """Descifra datos con AES-GCM o AES-CBC + HMAC."""
        if not isinstance(enc, str) or not enc.strip():
            raise ValueError("Datos cifrados deben ser una cadena no vacía")

        if self.use_gcm:
            return self._decrypt_gcm(enc)
        else:
            return self._decrypt_cbc_hmac(enc)

    def _encrypt_gcm(self, raw: str) -> str:
        """Cifrado autenticado con AES-GCM."""
        iv = get_random_bytes(12)  # 12 bytes recomendado para GCM
        cipher = AES.new(self.key, AES.MODE_GCM, nonce=iv)
        ciphertext, tag = cipher.encrypt_and_digest(raw.encode('utf-8'))
        # Concatenar: IV (12) + Tag (16) + Ciphertext
        result = iv + tag + ciphertext
        return base64.b64encode(result).decode('utf-8')

    def _decrypt_gcm(self, enc: str) -> str:
        """Descifrado autenticado con AES-GCM."""
        try:
            enc_bytes = base64.b64decode(enc)
            iv = enc_bytes[:12]
            tag = enc_bytes[12:28]
            ciphertext = enc_bytes[28:]
            cipher = AES.new(self.key, AES.MODE_GCM, nonce=iv)
            plaintext = cipher.decrypt_and_verify(ciphertext, tag)
            return plaintext.decode('utf-8')
        except (ValueError, KeyError) as e:
            logger.error(f"Error al descifrar con GCM: {e}")
            raise ValueError("Datos corruptos o clave incorrecta")

    def _encrypt_cbc_hmac(self, raw: str) -> str:
        """Cifrado con AES-CBC y autenticación HMAC."""
        raw_padded = pad(raw.encode('utf-8'), self.bs)
        iv = get_random_bytes(self.bs)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        encrypted = cipher.encrypt(raw_padded)
        # Calcular HMAC sobre IV + ciphertext
        hmac_value = hmac.new(self.hmac_key, iv + encrypted, hashlib.sha256).digest()
        # Concatenar: IV (16) + HMAC (32) + Ciphertext
        result = iv + hmac_value + encrypted
        return base64.b64encode(result).decode('utf-8')

    def _decrypt_cbc_hmac(self, enc: str) -> str:
        """Descifrado con AES-CBC y verificación HMAC."""
        try:
            enc_bytes = base64.b64decode(enc)
            iv = enc_bytes[:self.bs]
            hmac_value = enc_bytes[self.bs:self.bs + 32]
            ciphertext = enc_bytes[self.bs + 32:]
            # Verificar HMAC
            expected_hmac = hmac.new(self.hmac_key, iv + ciphertext, hashlib.sha256).digest()
            if not hmac.compare_digest(hmac_value, expected_hmac):
                raise ValueError("HMAC no coincide. Datos manipulados.")
            cipher = AES.new(self.key, AES.MODE_CBC, iv)
            decrypted = unpad(cipher.decrypt(ciphertext), self.bs)
            return decrypted.decode('utf-8')
        except (ValueError, KeyError) as e:
            logger.error(f"Error al descifrar con CBC+HMAC: {e}")
            raise ValueError("Datos corruptos o clave incorrecta")

    def get_salt(self) -> str:
        """Devuelve el salt en base64 para almacenamiento seguro."""
        return base64.b64encode(self.salt).decode('utf-8')

    async def stress_test(self, num_messages: int):
        """Prueba de estrés con cifrado/descifrado masivo."""
        messages = [f"Test message {i}" for i in range(num_messages)]
        tasks_encrypt = [asyncio.to_thread(self.encrypt, msg) for msg in messages]
        start_time = time.time()
        
        # Cifrar concurrentemente
        encrypted = await asyncio.gather(*tasks_encrypt)
        logger.info(f"Cifrado de {num_messages} mensajes en {time.time() - start_time:.2f}s")

        # Descifrar concurrentemente
        tasks_decrypt = [asyncio.to_thread(self.decrypt, enc) for enc in encrypted]
        decrypted = await asyncio.gather(*tasks_decrypt, return_exceptions=True)
        elapsed = time.time() - start_time

        # Verificar integridad
        failures = sum(1 for orig, dec in zip(messages, decrypted) if isinstance(dec, Exception) or orig != dec)
        logger.info(f"Prueba completada en {elapsed:.2f}s. Fallos: {failures}/{num_messages}")

# Prueba
if __name__ == "__main__":
    key = "mysecretpassword"
    cipher = AESCipher(key, use_gcm=True)

    # Prueba simple
    original = "Datos sensibles"
    encrypted = cipher.encrypt(original)
    decrypted = cipher.decrypt(encrypted)
    print(f"Original: {original}")
    print(f"Cifrado: {encrypted}")
    print(f"Descifrado: {decrypted}")
    print(f"Salt: {cipher.get_salt()}")

    # Prueba de estrés
    print("\nIniciando prueba de estrés...")
    asyncio.run(cipher.stress_test(100000))




Analytics manager




import json
import logging
import os
from typing import Dict, Any, List, Optional
from collections import deque
from datetime import datetime
import matplotlib.pyplot as plt
import numpy as np
from concurrent.futures import ThreadPoolExecutor
import asyncio
from aiofile import async_open  # Para operaciones asíncronas de I/O

# Configuración de logging
logger = logging.getLogger("AnalyticsManager")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()],
)


class AnalyticsManager:
    """
    Analiza el rendimiento de estrategias y genera gráficos de rendimiento de manera eficiente.
    """
    def __init__(self, historial_path: str = "data/performance.json", max_hist: int = 1000):
        self.historial_path = historial_path
        self.history: Dict[str, deque] = {}
        self.max_hist = max(0, max_hist)  # Evita valores negativos
        self.executor = ThreadPoolExecutor(max_workers=5)
        self.loop = asyncio.get_event_loop()
        if os.path.exists(historial_path):
            self.loop.run_until_complete(self._load_history())

    async def _load_history(self) -> None:
        """Carga el historial de manera asíncrona."""
        try:
            async with async_open(self.historial_path, "r") as f:
                data = json.loads(await f.read())
            self.history = {
                k: deque(v, maxlen=self.max_hist)
                for k, v in data.get("history", {}).items()
            }
            logger.info("Historial de rendimiento cargado correctamente.")
        except (json.JSONDecodeError, IOError) as e:
            logger.warning(f"No se pudo cargar historial: {type(e).__name__} - {e}")

    async def _save_history(self) -> None:
        """Guarda el historial de manera asíncrona."""
        try:
            os.makedirs(os.path.dirname(self.historial_path), exist_ok=True)
            async with async_open(self.historial_path, "w") as f:
                await f.write(
                    json.dumps(
                        {"history": {k: list(v) for k, v in self.history.items()}},
                        indent=2,
                    )
                )
        except (IOError, TypeError) as e:
            logger.error(f"Error al guardar historial: {type(e).__name__} - {e}")

    async def registrar_resultado(self, strategy_name: str, score: float) -> None:
        """Registra un resultado de forma asíncrona con validación."""
        if not isinstance(strategy_name, str) or not strategy_name.strip():
            raise ValueError("El nombre de la estrategia debe ser una cadena no vacía.")
        if not isinstance(score, (int, float)) or not (-float("inf") < score < float("inf")):
            raise ValueError("El score debe ser un número finito.")

        strategy_name = strategy_name.strip()
        if strategy_name not in self.history:
            self.history[strategy_name] = deque(maxlen=self.max_hist)
        self.history[strategy_name].append(
            {"timestamp": datetime.utcnow().isoformat(), "score": float(score)}
        )
        await self._save_history()

    def calcular_promedio(self, strategy_name: str) -> Optional[float]:
        """Calcula el promedio de puntajes de una estrategia."""
        hist = self.history.get(strategy_name)
        if not hist:
            return None
        # Usamos np.mean directamente para mayor eficiencia
        return float(np.mean([entry["score"] for entry in hist]))

    def estrategia_recomendada(self) -> Optional[str]:
        """Devuelve la estrategia con el mejor promedio."""
        if not self.history:
            return None
        
        # Usamos un diccionario de comprensión y max en una sola pasada
        promedios = {name: self.calcular_promedio(name) for name in self.history}
        validos = {k: v for k, v in promedios.items() if v is not None}
        if not validos:
            return None
        
        mejor = max(validos, key=validos.get)
        logger.info(f"Estrategia recomendada: {mejor} ({validos[mejor]:.4f})")
        return mejor

    def generar_grafico(self, strategy_name: str, output_path: Optional[str] = None) -> None:
        """Genera un gráfico del rendimiento de una estrategia."""
        hist = self.history.get(strategy_name)
        if not hist:
            logger.warning(f"No hay historial para {strategy_name}")
            return

        fechas = np.array([datetime.fromisoformat(d["timestamp"]) for d in hist])
        scores = np.array([d["score"] for d in hist])

        plt.figure(figsize=(10, 4))
        plt.plot(fechas, scores, marker="o", linestyle="-", color="b", label=strategy_name)
        plt.title(f"Rendimiento de {strategy_name}", fontsize=12, pad=10)
        plt.xlabel("Fecha", fontsize=10)
        plt.ylabel("Score", fontsize=10)
        plt.legend()
        plt.grid(True, linestyle="--", alpha=0.7)
        plt.tight_layout()

        if output_path:
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            plt.savefig(output_path, dpi=300, bbox_inches="tight")
            plt.close()  # Cierra la figura para liberar memoria
            logger.info(f"Gráfico guardado en {output_path}")
        else:
            plt.show()

    def obtener_historial(self, strategy_name: str) -> List[Dict[str, Any]]:
        """Devuelve el historial de una estrategia."""
        return list(self.history.get(strategy_name, []))


# Prueba rápida
async def main():
    analytics = AnalyticsManager()
    
    # Simulación asíncrona
    await asyncio.gather(
        analytics.registrar_resultado("sma_crossover", 0.82),
        analytics.registrar_resultado("sma_crossover", 0.67),
        analytics.registrar_resultado("rsi", 0.61),
        analytics.registrar_resultado("macd", 0.44),
    )

    mejor = analytics.estrategia_recomendada()
    print(f"Estrategia recomendada: {mejor}")

    # Graficar
    analytics.generar_grafico("sma_crossover", output_path="data/plots/sma_crossover.png")


if __name__ == "__main__":
    asyncio.run(main())





Anomaly detector





import logging
import asyncio
import numpy as np
from typing import List, Dict, Optional, Callable
from datetime import datetime
from collections import deque
from sklearn.ensemble import IsolationForest
from system.email_notifier import EmailNotifier  # Asumo que existe este módulo

logger = logging.getLogger("AnomalyDetector")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()],
)


class AnomalyDetector:
    """
    Detecta spikes, spreads extremos, manipulación y errores en datos de mercado.
    Usa Isolation Forest y análisis estadístico para identificar anomalías en tiempo real.
    """
    def __init__(
        self,
        threshold: float = 3.0,
        window_size: int = 100,
        notifier: Optional[EmailNotifier] = None,
        contamination: float = 0.01,
        alert_interval: float = 300.0,
    ):
        self.price_history: Dict[str, deque] = {}
        self.threshold = max(0.1, float(threshold))  # Evita umbrales inválidos
        self.window_size = max(10, int(window_size))  # Mínimo razonable
        self.model = IsolationForest(
            n_estimators=100,
            contamination=max(0.001, min(0.5, contamination)),  # Rango válido
            random_state=42,
            n_jobs=-1,  # Usa todos los núcleos
        )
        self.notifier = notifier
        self.last_alert: Dict[str, float] = {}
        self.alert_interval = max(1.0, float(alert_interval))  # Mínimo 1 segundo
        self._min_samples = 20  # Mínimo para análisis estadístico/IA

    def _should_alert(self, symbol: str) -> bool:
        """Determina si se debe enviar una alerta según el intervalo."""
        now = datetime.utcnow().timestamp()
        last = self.last_alert.get(symbol, 0.0)
        if now - last >= self.alert_interval:
            self.last_alert[symbol] = now
            return True
        return False

    def update_price(self, symbol: str, price: float) -> None:
        """Actualiza el historial de precios con validación."""
        if not isinstance(symbol, str) or not symbol.strip():
            logger.debug(f"Symbol inválido: {symbol}")
            return
        if not isinstance(price, (int, float)) or price <= 0:
            logger.debug(f"Precio inválido para {symbol}: {price}")
            return

        symbol = symbol.strip()
        if symbol not in self.price_history:
            self.price_history[symbol] = deque(maxlen=self.window_size)
        self.price_history[symbol].append(float(price))

    async def detect(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Detecta anomalías usando estadísticas y Isolation Forest."""
        hist = self.price_history.get(symbol)
        if not hist or len(hist) < self._min_samples:
            return None

        prices = np.array(hist, dtype=np.float32).reshape(-1, 1)
        current_price = prices[-1, 0]

        # Cálculo estadístico eficiente
        mean = np.mean(prices, axis=0)[0]
        std = np.std(prices, axis=0, ddof=1)[0]  # ddof=1 para muestra
        z_score = abs(current_price - mean) / (std + 1e-8)

        # Detección con IA
        try:
            prediction = self.model.fit_predict(prices)[-1]  # -1 es anomalía
        except ValueError as e:
            logger.warning(f"Error en IsolationForest para {symbol}: {e}")
            prediction = 1  # Normal si falla

        # Evaluar anomalía
        is_anomaly = z_score > self.threshold or prediction == -1
        if is_anomaly and self._should_alert(symbol):
            mensaje = (
                f"Anomalía detectada en {symbol}\n"
                f"Z-Score: {z_score:.2f}\n"
                f"Precio actual: {current_price:.2f}\n"
                f"Promedio: {mean:.2f}, STD: {std:.2f}\n"
                f"IA: {'Manipulación detectada' if prediction == -1 else 'Normal'}"
            )
            logger.warning(mensaje)
            if self.notifier:
                asyncio.create_task(  # No bloquea el flujo principal
                    self.notifier.enviar_email(
                        asunto=f"[ALERTA Genesis] Anomalía en {symbol}",
                        mensaje=mensaje,
                    )
                )
            return {
                "symbol": symbol,
                "z_score": float(z_score),
                "manipulacion": prediction == -1,
                "price": float(current_price),
                "mean": float(mean),
                "std": float(std),
                "mensaje": mensaje,
            }
        return None

    async def monitor(self, symbols: List[str], price_fetcher: Callable[[str], float]) -> None:
        """
        Monitorea símbolos en tiempo real detectando anomalías.
        Args:
            symbols: Lista de símbolos a monitorear.
            price_fetcher: Función asíncrona que devuelve el precio de un símbolo.
        """
        if not symbols or not callable(price_fetcher):
            logger.error("Lista de símbolos vacía o price_fetcher no válido")
            return

        while True:
            try:
                tasks = []
                for symbol in symbols:
                    try:
                        price = await price_fetcher(symbol)
                        if price is not None:
                            self.update_price(symbol, price)
                            tasks.append(self.detect(symbol))
                    except Exception as e:
                        logger.debug(f"Error al obtener precio de {symbol}: {e}")
                results = await asyncio.gather(*tasks, return_exceptions=True)
                for result in results:
                    if isinstance(result, Exception):
                        logger.debug(f"Error en detección: {result}")
                await asyncio.sleep(3.0)  # Intervalo configurable si se desea
            except asyncio.CancelledError:
                logger.info("Monitoreo cancelado")
                break
            except Exception as e:
                logger.error(f"Error en bucle de monitoreo: {e}")
                await asyncio.sleep(5.0)  # Pausa antes de reintentar


# Ejemplo de uso
async def dummy_price_fetcher(symbol: str) -> float:
    """Simulador de precios para pruebas."""
    return np.random.uniform(50, 150)


async def main():
    detector = AnomalyDetector(threshold=2.5, window_size=50)
    symbols = ["BTC/USD", "ETH/USD"]

    # Simular algunos datos iniciales
    for symbol in symbols:
        for _ in range(30):
            detector.update_price(symbol, await dummy_price_fetcher(symbol))

    # Iniciar monitoreo
    await detector.monitor(symbols, dummy_price_fetcher)


if __name__ == "__main__":
    asyncio.run(main()



Analyticmanager



import sqlite3
import json
import logging
import os
from typing import Dict, Any, List, Optional
from collections import deque
from datetime import datetime
import matplotlib.pyplot as plt
import numpy as np
from concurrent.futures import ThreadPoolExecutor
import asyncio

logger = logging.getLogger("AnalyticsManager")
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

class AnalyticsManager:
    def __init__(self, db_path: str = "data/analytics.db", max_hist: int = 1000):
        self.db_path = db_path
        self.max_hist = max(0, max_hist)
        self.executor = ThreadPoolExecutor(max_workers=5)
        self._init_db()
        self.loop = asyncio.get_event_loop()

    def _init_db(self):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS performance (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    strategy_name TEXT NOT NULL,
                    timestamp TEXT NOT NULL,
                    score REAL NOT NULL
                )
            """)
            conn.commit()

    async def registrar_resultado(self, strategy_name: str, score: float) -> None:
        if not isinstance(strategy_name, str) or not strategy_name.strip():
            raise ValueError("El nombre de la estrategia debe ser una cadena no vacía.")
        if not isinstance(score, (int, float)) or not (-float("inf") < score < float("inf")):
            raise ValueError("El score debe ser un número finito.")

        timestamp = datetime.utcnow().isoformat()
        await self.loop.run_in_executor(
            self.executor,
            lambda: self._insert_record(strategy_name, timestamp, score)
        )

    def _insert_record(self, strategy_name: str, timestamp: str, score: float):
        with sqlite3.connect(self.db_path) as conn:
            # Mantener solo los últimos max_hist registros por estrategia
            conn.execute("""
                DELETE FROM performance WHERE strategy_name = ? AND id NOT IN (
                    SELECT id FROM performance WHERE strategy_name = ? 
                    ORDER BY timestamp DESC LIMIT ?
                )
            """, (strategy_name, strategy_name, self.max_hist))
            conn.execute(
                "INSERT INTO performance (strategy_name, timestamp, score) VALUES (?, ?, ?)",
                (strategy_name, timestamp, score)
            )
            conn.commit()

    def calcular_promedio(self, strategy_name: str) -> Optional[float]:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT AVG(score) FROM performance WHERE strategy_name = ?",
                (strategy_name,)
            )
            result = cursor.fetchone()[0]
            return float(result) if result is not None else None

    def estrategia_recomendada(self) -> Optional[str]:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT strategy_name, AVG(score) as avg_score 
                FROM performance 
                GROUP BY strategy_name 
                HAVING COUNT(*) > 0
            """)
            results = {row[0]: row[1] for row in cursor.fetchall()}
            if not results:
                return None
            best = max(results, key=results.get)
            logger.info(f"Estrategia recomendada: {best} ({results[best]:.4f})")
            return best

    def generar_grafico(self, strategy_name: str, output_path: Optional[str] = None) -> None:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT timestamp, score FROM performance WHERE strategy_name = ? ORDER BY timestamp",
                (strategy_name,)
            )
            data = cursor.fetchall()
            if not data:
                logger.warning(f"No hay historial para {strategy_name}")
                return

        fechas = np.array([datetime.fromisoformat(row[0]) for row in data])
        scores = np.array([row[1] for row in data])

        plt.figure(figsize=(10, 4))
        plt.plot(fechas, scores, marker="o", linestyle="-", color="b", label=strategy_name)
        plt.title(f"Rendimiento de {strategy_name}", fontsize=12, pad=10)
        plt.xlabel("Fecha", fontsize=10)
        plt.ylabel("Score", fontsize=10)
        plt.legend()
        plt.grid(True, linestyle="--", alpha=0.7)
        plt.tight_layout()

        if output_path:
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            plt.savefig(output_path, dpi=300, bbox_inches="tight")
            plt.close()
            logger.info(f"Gráfico guardado en {output_path}")
        else:
            plt.show()

    def obtener_historial(self, strategy_name: str) -> List[Dict[str, Any]]:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT timestamp, score FROM performance WHERE strategy_name = ? ORDER BY timestamp",
                (strategy_name,)
            )
            return [{"timestamp": row[0], "score": row[1]} for row in cursor.fetchall()]

async def main():
    analytics = AnalyticsManager()
    await asyncio.gather(
        analytics.registrar_resultado("sma_crossover", 0.82),
        analytics.registrar_resultado("sma_crossover", 0.67),
        analytics.registrar_resultado("rsi", 0.61),
        analytics.registrar_resultado("macd", 0.44),
    )
    print(f"Estrategia recomendada: {analytics.estrategia_recomendada()}")
    analytics.generar_grafico("sma_crossover", "data/plots/sma_crossover.png")

if __name__ == "__main__":
    asyncio.run(main())



